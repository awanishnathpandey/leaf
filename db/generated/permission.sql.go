// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: permission.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const AddPermissionToRole = `-- name: AddPermissionToRole :exec
INSERT INTO role_permissions (role_id, permission_id, created_at, updated_at) 
VALUES ($1, $2, EXTRACT(EPOCH FROM NOW()), EXTRACT(EPOCH FROM NOW())) 
ON CONFLICT DO NOTHING
`

type AddPermissionToRoleParams struct {
	RoleID       int64 `db:"role_id" json:"role_id"`
	PermissionID int64 `db:"permission_id" json:"permission_id"`
}

func (q *Queries) AddPermissionToRole(ctx context.Context, arg AddPermissionToRoleParams) error {
	_, err := q.db.Exec(ctx, AddPermissionToRole, arg.RoleID, arg.PermissionID)
	return err
}

const AddRoleToUser = `-- name: AddRoleToUser :exec
INSERT INTO user_roles (role_id, user_id, created_at, updated_at) 
VALUES ($1, $2, EXTRACT(EPOCH FROM NOW()), EXTRACT(EPOCH FROM NOW())) 
ON CONFLICT DO NOTHING
`

type AddRoleToUserParams struct {
	RoleID int64 `db:"role_id" json:"role_id"`
	UserID int64 `db:"user_id" json:"user_id"`
}

func (q *Queries) AddRoleToUser(ctx context.Context, arg AddRoleToUserParams) error {
	_, err := q.db.Exec(ctx, AddRoleToUser, arg.RoleID, arg.UserID)
	return err
}

const CreatePermission = `-- name: CreatePermission :one
INSERT INTO roles (name, description, created_by, updated_by) 
VALUES ($1, $2, $3, $3) 
RETURNING id, name, description, created_at, updated_at, created_by, updated_by
`

type CreatePermissionParams struct {
	Name        string `db:"name" json:"name"`
	Description string `db:"description" json:"description"`
	CreatedBy   string `db:"created_by" json:"created_by"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Role, error) {
	row := q.db.QueryRow(ctx, CreatePermission, arg.Name, arg.Description, arg.CreatedBy)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const CreateRole = `-- name: CreateRole :one
INSERT INTO roles (name, description, created_by, updated_by) 
VALUES ($1, $2, $3, $3) 
RETURNING id, name, description, created_at, updated_at, created_by, updated_by
`

type CreateRoleParams struct {
	Name        string `db:"name" json:"name"`
	Description string `db:"description" json:"description"`
	CreatedBy   string `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, CreateRole, arg.Name, arg.Description, arg.CreatedBy)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const DeletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions 
WHERE id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, DeletePermission, id)
	return err
}

const DeletePermissionsByIDs = `-- name: DeletePermissionsByIDs :exec
DELETE FROM permissions
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeletePermissionsByIDs(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, DeletePermissionsByIDs, dollar_1)
	return err
}

const DeleteRole = `-- name: DeleteRole :exec
DELETE FROM roles 
WHERE id = $1
`

func (q *Queries) DeleteRole(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, DeleteRole, id)
	return err
}

const DeleteRolesByIDs = `-- name: DeleteRolesByIDs :exec
DELETE FROM roles
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteRolesByIDs(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, DeleteRolesByIDs, dollar_1)
	return err
}

const GetPaginatedPermissionsByRoleID = `-- name: GetPaginatedPermissionsByRoleID :many
SELECT id, name, description, p.created_at, p.updated_at, p.created_by, p.updated_by, role_id, permission_id, rp.created_at, rp.updated_at, rp.created_by, rp.updated_by FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE 
    rp.role_id = $3  -- Filter by permission_id
    AND (coalesce($4, '') = '' OR p.name ILIKE '%' || $4 || '%')
    AND (coalesce($5, '') = '' OR p.description ILIKE '%' || $5 || '%')
ORDER BY 
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'ASC' THEN p.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'ASC' THEN p.description 
    END ASC,
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'DESC' THEN p.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'DESC' THEN p.description 
    END DESC
LIMIT $1
OFFSET $2
`

type GetPaginatedPermissionsByRoleIDParams struct {
	Limit             int32       `db:"limit" json:"limit"`
	Offset            int32       `db:"offset" json:"offset"`
	RoleID            pgtype.Int8 `db:"role_id" json:"role_id"`
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
	SortField         interface{} `db:"sort_field" json:"sort_field"`
	SortOrder         interface{} `db:"sort_order" json:"sort_order"`
}

type GetPaginatedPermissionsByRoleIDRow struct {
	ID           int64  `db:"id" json:"id"`
	Name         string `db:"name" json:"name"`
	Description  string `db:"description" json:"description"`
	CreatedAt    int64  `db:"created_at" json:"created_at"`
	UpdatedAt    int64  `db:"updated_at" json:"updated_at"`
	CreatedBy    string `db:"created_by" json:"created_by"`
	UpdatedBy    string `db:"updated_by" json:"updated_by"`
	RoleID       int64  `db:"role_id" json:"role_id"`
	PermissionID int64  `db:"permission_id" json:"permission_id"`
	CreatedAt_2  int64  `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2  int64  `db:"updated_at_2" json:"updated_at_2"`
	CreatedBy_2  string `db:"created_by_2" json:"created_by_2"`
	UpdatedBy_2  string `db:"updated_by_2" json:"updated_by_2"`
}

func (q *Queries) GetPaginatedPermissionsByRoleID(ctx context.Context, arg GetPaginatedPermissionsByRoleIDParams) ([]GetPaginatedPermissionsByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, GetPaginatedPermissionsByRoleID,
		arg.Limit,
		arg.Offset,
		arg.RoleID,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaginatedPermissionsByRoleIDRow{}
	for rows.Next() {
		var i GetPaginatedPermissionsByRoleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPaginatedPermissionsByRoleIDCount = `-- name: GetPaginatedPermissionsByRoleIDCount :one
SELECT COUNT(*) FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE 
    rp.role_id = $1  -- Filter by permission_id
    AND (coalesce($2, '') = '' OR p.name ILIKE '%' || $2 || '%')
    AND (coalesce($3, '') = '' OR p.description ILIKE '%' || $3 || '%')
`

type GetPaginatedPermissionsByRoleIDCountParams struct {
	RoleID            pgtype.Int8 `db:"role_id" json:"role_id"`
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
}

func (q *Queries) GetPaginatedPermissionsByRoleIDCount(ctx context.Context, arg GetPaginatedPermissionsByRoleIDCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, GetPaginatedPermissionsByRoleIDCount, arg.RoleID, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetPaginatedRolesByPermissionID = `-- name: GetPaginatedRolesByPermissionID :many
SELECT id, name, description, r.created_at, r.updated_at, r.created_by, r.updated_by, role_id, permission_id, rp.created_at, rp.updated_at, rp.created_by, rp.updated_by FROM roles r
JOIN role_permissions rp ON r.id = rp.role_id
WHERE 
    rp.permission_id = $3  -- Filter by permission_id
    AND (coalesce($4, '') = '' OR r.name ILIKE '%' || $4 || '%')
    AND (coalesce($5, '') = '' OR r.description ILIKE '%' || $5 || '%')
ORDER BY 
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'ASC' THEN r.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'ASC' THEN r.description 
    END ASC,
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'DESC' THEN r.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'DESC' THEN r.description 
    END DESC
LIMIT $1
OFFSET $2
`

type GetPaginatedRolesByPermissionIDParams struct {
	Limit             int32       `db:"limit" json:"limit"`
	Offset            int32       `db:"offset" json:"offset"`
	PermissionID      pgtype.Int8 `db:"permission_id" json:"permission_id"`
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
	SortField         interface{} `db:"sort_field" json:"sort_field"`
	SortOrder         interface{} `db:"sort_order" json:"sort_order"`
}

type GetPaginatedRolesByPermissionIDRow struct {
	ID           int64  `db:"id" json:"id"`
	Name         string `db:"name" json:"name"`
	Description  string `db:"description" json:"description"`
	CreatedAt    int64  `db:"created_at" json:"created_at"`
	UpdatedAt    int64  `db:"updated_at" json:"updated_at"`
	CreatedBy    string `db:"created_by" json:"created_by"`
	UpdatedBy    string `db:"updated_by" json:"updated_by"`
	RoleID       int64  `db:"role_id" json:"role_id"`
	PermissionID int64  `db:"permission_id" json:"permission_id"`
	CreatedAt_2  int64  `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2  int64  `db:"updated_at_2" json:"updated_at_2"`
	CreatedBy_2  string `db:"created_by_2" json:"created_by_2"`
	UpdatedBy_2  string `db:"updated_by_2" json:"updated_by_2"`
}

func (q *Queries) GetPaginatedRolesByPermissionID(ctx context.Context, arg GetPaginatedRolesByPermissionIDParams) ([]GetPaginatedRolesByPermissionIDRow, error) {
	rows, err := q.db.Query(ctx, GetPaginatedRolesByPermissionID,
		arg.Limit,
		arg.Offset,
		arg.PermissionID,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaginatedRolesByPermissionIDRow{}
	for rows.Next() {
		var i GetPaginatedRolesByPermissionIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPaginatedRolesByPermissionIDCount = `-- name: GetPaginatedRolesByPermissionIDCount :one
SELECT COUNT(*) FROM roles r
JOIN role_permissions rp ON r.id = rp.role_id
WHERE 
    rp.permission_id = $1  -- Filter by permission_id
    AND (coalesce($2, '') = '' OR r.name ILIKE '%' || $2 || '%')
    AND (coalesce($3, '') = '' OR r.description ILIKE '%' || $3 || '%')
`

type GetPaginatedRolesByPermissionIDCountParams struct {
	PermissionID      pgtype.Int8 `db:"permission_id" json:"permission_id"`
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
}

func (q *Queries) GetPaginatedRolesByPermissionIDCount(ctx context.Context, arg GetPaginatedRolesByPermissionIDCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, GetPaginatedRolesByPermissionIDCount, arg.PermissionID, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetPaginatedRolesByUserID = `-- name: GetPaginatedRolesByUserID :many
SELECT id, name, description, r.created_at, r.updated_at, r.created_by, r.updated_by, user_id, role_id, ur.created_at, ur.updated_at, ur.created_by, ur.updated_by FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE 
    ur.user_id = $3  -- Filter by user_id
    AND (coalesce($4, '') = '' OR r.name ILIKE '%' || $4 || '%')
    AND (coalesce($5, '') = '' OR r.description ILIKE '%' || $5 || '%')
ORDER BY 
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'ASC' THEN r.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'ASC' THEN r.description 
    END ASC,
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'DESC' THEN r.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'DESC' THEN r.description 
    END DESC
LIMIT $1
OFFSET $2
`

type GetPaginatedRolesByUserIDParams struct {
	Limit             int32       `db:"limit" json:"limit"`
	Offset            int32       `db:"offset" json:"offset"`
	UserID            pgtype.Int8 `db:"user_id" json:"user_id"`
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
	SortField         interface{} `db:"sort_field" json:"sort_field"`
	SortOrder         interface{} `db:"sort_order" json:"sort_order"`
}

type GetPaginatedRolesByUserIDRow struct {
	ID          int64  `db:"id" json:"id"`
	Name        string `db:"name" json:"name"`
	Description string `db:"description" json:"description"`
	CreatedAt   int64  `db:"created_at" json:"created_at"`
	UpdatedAt   int64  `db:"updated_at" json:"updated_at"`
	CreatedBy   string `db:"created_by" json:"created_by"`
	UpdatedBy   string `db:"updated_by" json:"updated_by"`
	UserID      int64  `db:"user_id" json:"user_id"`
	RoleID      int64  `db:"role_id" json:"role_id"`
	CreatedAt_2 int64  `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2 int64  `db:"updated_at_2" json:"updated_at_2"`
	CreatedBy_2 string `db:"created_by_2" json:"created_by_2"`
	UpdatedBy_2 string `db:"updated_by_2" json:"updated_by_2"`
}

func (q *Queries) GetPaginatedRolesByUserID(ctx context.Context, arg GetPaginatedRolesByUserIDParams) ([]GetPaginatedRolesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, GetPaginatedRolesByUserID,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaginatedRolesByUserIDRow{}
	for rows.Next() {
		var i GetPaginatedRolesByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.UserID,
			&i.RoleID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPaginatedRolesByUserIDCount = `-- name: GetPaginatedRolesByUserIDCount :one
SELECT COUNT(*) FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE 
    ur.user_id = $1  -- Filter by user_id
    AND (coalesce($2, '') = '' OR r.name ILIKE '%' || $2 || '%')
    AND (coalesce($3, '') = '' OR r.description ILIKE '%' || $3 || '%')
`

type GetPaginatedRolesByUserIDCountParams struct {
	UserID            pgtype.Int8 `db:"user_id" json:"user_id"`
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
}

func (q *Queries) GetPaginatedRolesByUserIDCount(ctx context.Context, arg GetPaginatedRolesByUserIDCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, GetPaginatedRolesByUserIDCount, arg.UserID, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetPaginatedUsersByRoleID = `-- name: GetPaginatedUsersByRoleID :many
SELECT 
    u.id, 
    u.first_name,
    u.last_name, 
    u.email,
    u.job_title,
    u.line_of_business,
    u.line_manager, 
    u.email_verified_at, 
    u.last_seen_at, 
    u.created_at, 
    u.updated_at, 
    u.deleted_at,
    u.created_by,
    u.updated_by
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
WHERE 
    ur.role_id = $3  -- Filter by role_id
    AND (coalesce($4, '') = '' OR u.first_name ILIKE '%' || $4 || '%')
    AND (coalesce($5, '') = '' OR u.email ILIKE '%' || $5 || '%')
ORDER BY 
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'ASC' THEN u.first_name 
        WHEN $6 = 'EMAIL' AND $7 = 'ASC' THEN u.email 
    END ASC,
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'DESC' THEN u.first_name 
        WHEN $6 = 'EMAIL' AND $7 = 'DESC' THEN u.email 
    END DESC
LIMIT $1
OFFSET $2
`

type GetPaginatedUsersByRoleIDParams struct {
	Limit       int32       `db:"limit" json:"limit"`
	Offset      int32       `db:"offset" json:"offset"`
	RoleID      pgtype.Int8 `db:"role_id" json:"role_id"`
	NameFilter  interface{} `db:"name_filter" json:"name_filter"`
	EmailFilter interface{} `db:"email_filter" json:"email_filter"`
	SortField   interface{} `db:"sort_field" json:"sort_field"`
	SortOrder   interface{} `db:"sort_order" json:"sort_order"`
}

type GetPaginatedUsersByRoleIDRow struct {
	ID              int64       `db:"id" json:"id"`
	FirstName       string      `db:"first_name" json:"first_name"`
	LastName        string      `db:"last_name" json:"last_name"`
	Email           string      `db:"email" json:"email"`
	JobTitle        pgtype.Text `db:"job_title" json:"job_title"`
	LineOfBusiness  pgtype.Text `db:"line_of_business" json:"line_of_business"`
	LineManager     pgtype.Text `db:"line_manager" json:"line_manager"`
	EmailVerifiedAt pgtype.Int8 `db:"email_verified_at" json:"email_verified_at"`
	LastSeenAt      int64       `db:"last_seen_at" json:"last_seen_at"`
	CreatedAt       int64       `db:"created_at" json:"created_at"`
	UpdatedAt       int64       `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Int8 `db:"deleted_at" json:"deleted_at"`
	CreatedBy       string      `db:"created_by" json:"created_by"`
	UpdatedBy       string      `db:"updated_by" json:"updated_by"`
}

func (q *Queries) GetPaginatedUsersByRoleID(ctx context.Context, arg GetPaginatedUsersByRoleIDParams) ([]GetPaginatedUsersByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, GetPaginatedUsersByRoleID,
		arg.Limit,
		arg.Offset,
		arg.RoleID,
		arg.NameFilter,
		arg.EmailFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaginatedUsersByRoleIDRow{}
	for rows.Next() {
		var i GetPaginatedUsersByRoleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.JobTitle,
			&i.LineOfBusiness,
			&i.LineManager,
			&i.EmailVerifiedAt,
			&i.LastSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPaginatedUsersByRoleIDCount = `-- name: GetPaginatedUsersByRoleIDCount :one
SELECT COUNT(*)
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
WHERE 
    ur.role_id = $1  -- Filter by role_id
    AND (coalesce($2, '') = '' OR u.name ILIKE '%' || $2 || '%')
    AND (coalesce($3, '') = '' OR u.email ILIKE '%' || $3 || '%')
`

type GetPaginatedUsersByRoleIDCountParams struct {
	RoleID      pgtype.Int8 `db:"role_id" json:"role_id"`
	NameFilter  interface{} `db:"name_filter" json:"name_filter"`
	EmailFilter interface{} `db:"email_filter" json:"email_filter"`
}

func (q *Queries) GetPaginatedUsersByRoleIDCount(ctx context.Context, arg GetPaginatedUsersByRoleIDCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, GetPaginatedUsersByRoleIDCount, arg.RoleID, arg.NameFilter, arg.EmailFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetPermission = `-- name: GetPermission :one
SELECT id, name, description, created_at, updated_at 
FROM permissions 
WHERE id = $1
`

type GetPermissionRow struct {
	ID          int64  `db:"id" json:"id"`
	Name        string `db:"name" json:"name"`
	Description string `db:"description" json:"description"`
	CreatedAt   int64  `db:"created_at" json:"created_at"`
	UpdatedAt   int64  `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetPermission(ctx context.Context, id int64) (GetPermissionRow, error) {
	row := q.db.QueryRow(ctx, GetPermission, id)
	var i GetPermissionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPermissionsByIDs = `-- name: GetPermissionsByIDs :many
SELECT id FROM permissions
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetPermissionsByIDs(ctx context.Context, dollar_1 []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, GetPermissionsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPermissionsByRoleID = `-- name: GetPermissionsByRoleID :many
SELECT p.id, p.name, p.description, p.created_at, p.updated_at, p.created_by, p.updated_by
FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE rp.role_id = $1
`

func (q *Queries) GetPermissionsByRoleID(ctx context.Context, roleID int64) ([]Permission, error) {
	rows, err := q.db.Query(ctx, GetPermissionsByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRole = `-- name: GetRole :one
SELECT id, name, description, created_at, updated_at 
FROM roles 
WHERE id = $1
`

type GetRoleRow struct {
	ID          int64  `db:"id" json:"id"`
	Name        string `db:"name" json:"name"`
	Description string `db:"description" json:"description"`
	CreatedAt   int64  `db:"created_at" json:"created_at"`
	UpdatedAt   int64  `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetRole(ctx context.Context, id int64) (GetRoleRow, error) {
	row := q.db.QueryRow(ctx, GetRole, id)
	var i GetRoleRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetRolesByIDs = `-- name: GetRolesByIDs :many
SELECT id FROM roles
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetRolesByIDs(ctx context.Context, dollar_1 []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, GetRolesByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRolesByPermissionID = `-- name: GetRolesByPermissionID :many
SELECT r.id, r.name, r.description, r.created_at, r.updated_at, r.created_by, r.updated_by
FROM roles r
JOIN role_permissions rp ON r.id = rp.role_id
WHERE rp.permission_id = $1
`

func (q *Queries) GetRolesByPermissionID(ctx context.Context, permissionID int64) ([]Role, error) {
	rows, err := q.db.Query(ctx, GetRolesByPermissionID, permissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRolesByUserID = `-- name: GetRolesByUserID :many
SELECT r.id, r.name, r.description, r.created_at, r.updated_at, r.created_by, r.updated_by
FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE ur.user_id = $1
`

func (q *Queries) GetRolesByUserID(ctx context.Context, userID int64) ([]Role, error) {
	rows, err := q.db.Query(ctx, GetRolesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserPermissions = `-- name: GetUserPermissions :many
SELECT p.name
        FROM permissions p
        JOIN role_permissions rp ON rp.permission_id = p.id
        JOIN user_roles ur ON ur.role_id = rp.role_id
        WHERE ur.user_id = $1
`

func (q *Queries) GetUserPermissions(ctx context.Context, userID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, GetUserPermissions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByRoleID = `-- name: GetUsersByRoleID :many
SELECT u.id, u.first_name, u.last_name, u.email, u.job_title, u.line_of_business, u.line_manager, u.email_verified_at, u.last_seen_at, u.created_at, u.updated_at, u.deleted_at
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
WHERE ur.role_id = $1
`

type GetUsersByRoleIDRow struct {
	ID              int64       `db:"id" json:"id"`
	FirstName       string      `db:"first_name" json:"first_name"`
	LastName        string      `db:"last_name" json:"last_name"`
	Email           string      `db:"email" json:"email"`
	JobTitle        pgtype.Text `db:"job_title" json:"job_title"`
	LineOfBusiness  pgtype.Text `db:"line_of_business" json:"line_of_business"`
	LineManager     pgtype.Text `db:"line_manager" json:"line_manager"`
	EmailVerifiedAt pgtype.Int8 `db:"email_verified_at" json:"email_verified_at"`
	LastSeenAt      int64       `db:"last_seen_at" json:"last_seen_at"`
	CreatedAt       int64       `db:"created_at" json:"created_at"`
	UpdatedAt       int64       `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Int8 `db:"deleted_at" json:"deleted_at"`
}

func (q *Queries) GetUsersByRoleID(ctx context.Context, roleID int64) ([]GetUsersByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, GetUsersByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersByRoleIDRow{}
	for rows.Next() {
		var i GetUsersByRoleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.JobTitle,
			&i.LineOfBusiness,
			&i.LineManager,
			&i.EmailVerifiedAt,
			&i.LastSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPermissions = `-- name: ListPermissions :many
SELECT id, name, description, created_at, updated_at, created_by, updated_by FROM permissions
ORDER BY name
`

func (q *Queries) ListPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.Query(ctx, ListPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRoles = `-- name: ListRoles :many
SELECT id, name, description, created_at, updated_at, created_by, updated_by FROM roles
ORDER BY name
`

func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, ListRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const PaginatedPermissions = `-- name: PaginatedPermissions :many
SELECT id, name, description, created_at, updated_at, created_by, updated_by FROM permissions
WHERE 
    (coalesce($3, '') = '' OR name ILIKE '%' || $3 || '%')
    AND (coalesce($4, '') = '' OR description ILIKE '%' || $4 || '%')
ORDER BY 
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'ASC' THEN name 
        WHEN $5 = 'DESCRIPTION' AND $6 = 'ASC' THEN description 
    END ASC,
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'DESC' THEN name 
        WHEN $5 = 'DESCRIPTION' AND $6 = 'DESC' THEN description 
    END DESC
LIMIT $1
OFFSET $2
`

type PaginatedPermissionsParams struct {
	Limit             int32       `db:"limit" json:"limit"`
	Offset            int32       `db:"offset" json:"offset"`
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
	SortField         interface{} `db:"sort_field" json:"sort_field"`
	SortOrder         interface{} `db:"sort_order" json:"sort_order"`
}

func (q *Queries) PaginatedPermissions(ctx context.Context, arg PaginatedPermissionsParams) ([]Permission, error) {
	rows, err := q.db.Query(ctx, PaginatedPermissions,
		arg.Limit,
		arg.Offset,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const PaginatedPermissionsCount = `-- name: PaginatedPermissionsCount :one
SELECT COUNT(*) FROM permissions
WHERE 
    (coalesce($1, '') = '' OR name ILIKE '%' || $1 || '%')
    AND (coalesce($2, '') = '' OR description ILIKE '%' || $2 || '%')
`

type PaginatedPermissionsCountParams struct {
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
}

func (q *Queries) PaginatedPermissionsCount(ctx context.Context, arg PaginatedPermissionsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, PaginatedPermissionsCount, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const PaginatedRoles = `-- name: PaginatedRoles :many
SELECT id, name, description, created_at, updated_at, created_by, updated_by FROM roles
WHERE 
    (coalesce($3, '') = '' OR name ILIKE '%' || $3 || '%')
    AND (coalesce($4, '') = '' OR description ILIKE '%' || $4 || '%')
ORDER BY 
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'ASC' THEN name 
        WHEN $5 = 'DESCRIPTION' AND $6 = 'ASC' THEN description 
    END ASC,
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'DESC' THEN name 
        WHEN $5 = 'DESCRIPTION' AND $6 = 'DESC' THEN description 
    END DESC
LIMIT $1
OFFSET $2
`

type PaginatedRolesParams struct {
	Limit             int32       `db:"limit" json:"limit"`
	Offset            int32       `db:"offset" json:"offset"`
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
	SortField         interface{} `db:"sort_field" json:"sort_field"`
	SortOrder         interface{} `db:"sort_order" json:"sort_order"`
}

func (q *Queries) PaginatedRoles(ctx context.Context, arg PaginatedRolesParams) ([]Role, error) {
	rows, err := q.db.Query(ctx, PaginatedRoles,
		arg.Limit,
		arg.Offset,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const PaginatedRolesCount = `-- name: PaginatedRolesCount :one
SELECT COUNT(*) FROM roles
WHERE 
    (coalesce($1, '') = '' OR name ILIKE '%' || $1 || '%')
    AND (coalesce($2, '') = '' OR description ILIKE '%' || $2 || '%')
`

type PaginatedRolesCountParams struct {
	NameFilter        interface{} `db:"name_filter" json:"name_filter"`
	DescriptionFilter interface{} `db:"description_filter" json:"description_filter"`
}

func (q *Queries) PaginatedRolesCount(ctx context.Context, arg PaginatedRolesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, PaginatedRolesCount, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const RemovePermissionFromRole = `-- name: RemovePermissionFromRole :exec
DELETE FROM role_permissions 
WHERE role_id = $1 AND permission_id = $2
`

type RemovePermissionFromRoleParams struct {
	RoleID       int64 `db:"role_id" json:"role_id"`
	PermissionID int64 `db:"permission_id" json:"permission_id"`
}

func (q *Queries) RemovePermissionFromRole(ctx context.Context, arg RemovePermissionFromRoleParams) error {
	_, err := q.db.Exec(ctx, RemovePermissionFromRole, arg.RoleID, arg.PermissionID)
	return err
}

const RemoveRoleFromUser = `-- name: RemoveRoleFromUser :exec
DELETE FROM user_roles 
WHERE role_id = $1 AND user_id = $2
`

type RemoveRoleFromUserParams struct {
	RoleID int64 `db:"role_id" json:"role_id"`
	UserID int64 `db:"user_id" json:"user_id"`
}

func (q *Queries) RemoveRoleFromUser(ctx context.Context, arg RemoveRoleFromUserParams) error {
	_, err := q.db.Exec(ctx, RemoveRoleFromUser, arg.RoleID, arg.UserID)
	return err
}

const UpdatePermission = `-- name: UpdatePermission :one
UPDATE permissions 
SET name = $1, description = $2, updated_at = EXTRACT(EPOCH FROM NOW()), updated_by = $4
WHERE id = $3
RETURNING id, name, description, created_at, updated_at, created_by, updated_by
`

type UpdatePermissionParams struct {
	Name        string `db:"name" json:"name"`
	Description string `db:"description" json:"description"`
	ID          int64  `db:"id" json:"id"`
	UpdatedBy   string `db:"updated_by" json:"updated_by"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, UpdatePermission,
		arg.Name,
		arg.Description,
		arg.ID,
		arg.UpdatedBy,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const UpdateRole = `-- name: UpdateRole :one
UPDATE roles 
SET name = $1, description = $2, updated_at = EXTRACT(EPOCH FROM NOW()), updated_by = $4
WHERE id = $3
RETURNING id, name, description, created_at, updated_at, created_by, updated_by
`

type UpdateRoleParams struct {
	Name        string `db:"name" json:"name"`
	Description string `db:"description" json:"description"`
	ID          int64  `db:"id" json:"id"`
	UpdatedBy   string `db:"updated_by" json:"updated_by"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, UpdateRole,
		arg.Name,
		arg.Description,
		arg.ID,
		arg.UpdatedBy,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}
