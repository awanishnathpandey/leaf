package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/awanishnathpandey/leaf/db/generated"
	"github.com/awanishnathpandey/leaf/graph"
	"github.com/awanishnathpandey/leaf/graph/model"
)

// UpdateAppConfig is the resolver for the updateAppConfig field.
func (r *mutationResolver) UpdateAppConfig(ctx context.Context, configKey string, configData any) (*model.AppConfig, error) {
	// Convert the configData to JSON string
	configDataBytes, err := json.Marshal(configData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal configData: %w", err)
	}

	// Update the configuration in the database using sqlc
	err = r.DB.UpdateAppConfigByKey(ctx, generated.UpdateAppConfigByKeyParams{
		ConfigKey:  configKey,
		ConfigData: configDataBytes,
		UpdatedBy:  ctx.Value("userEmail").(string),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update configuration for key %s: %w", configKey, err)
	}

	// Fetch the updated configuration
	config, err := r.DB.GetAppConfigByKey(ctx, configKey)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated configuration for key %s: %w", configKey, err)
	}

	// Unmarshal the updated configData to handle both map and array cases
	var updatedConfigData interface{}
	if err := json.Unmarshal([]byte(config.ConfigData), &updatedConfigData); err != nil {
		return nil, fmt.Errorf("failed to unmarshal updated configData: %w", err)
	}

	return &model.AppConfig{
		ID:         config.ID,
		ConfigKey:  config.ConfigKey,
		ConfigData: updatedConfigData, // Allow it to handle both map and array
		CreatedAt:  config.CreatedAt,
		UpdatedAt:  config.UpdatedAt,
		CreatedBy:  config.CreatedBy,
		UpdatedBy:  config.UpdatedBy,
	}, nil
}

// GetAppConfig is the resolver for the getAppConfig field.
func (r *queryResolver) GetAppConfig(ctx context.Context, configKey string) (*model.AppConfig, error) {
	// Fetch configuration from the database using sqlc
	config, err := r.DB.GetAppConfigByKey(ctx, configKey)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch configuration for key %s: %w", configKey, err)
	}

	// Dynamically unmarshal the JSON to handle both map and array cases
	var configData interface{}
	if err := json.Unmarshal(config.ConfigData, &configData); err != nil {
		return nil, fmt.Errorf("failed to unmarshal configData: %w", err)
	}

	// Return the AppConfig struct
	return &model.AppConfig{
		ID:         config.ID,
		ConfigKey:  config.ConfigKey,
		ConfigData: configData, // Directly use interface{} to support both map and array
		CreatedAt:  config.CreatedAt,
		UpdatedAt:  config.UpdatedAt,
		CreatedBy:  config.CreatedBy,
		UpdatedBy:  config.UpdatedBy,
	}, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
