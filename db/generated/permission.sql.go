// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: permission.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPermissionToRole = `-- name: AddPermissionToRole :exec
INSERT INTO role_permissions (role_id, permission_id, created_at, updated_at) 
VALUES ($1, $2, EXTRACT(EPOCH FROM NOW()), EXTRACT(EPOCH FROM NOW())) 
ON CONFLICT DO NOTHING
`

type AddPermissionToRoleParams struct {
	RoleID       int64 `json:"role_id"`
	PermissionID int64 `json:"permission_id"`
}

func (q *Queries) AddPermissionToRole(ctx context.Context, arg AddPermissionToRoleParams) error {
	_, err := q.db.Exec(ctx, addPermissionToRole, arg.RoleID, arg.PermissionID)
	return err
}

const addRoleToUser = `-- name: AddRoleToUser :exec
INSERT INTO user_roles (role_id, user_id, created_at, updated_at) 
VALUES ($1, $2, EXTRACT(EPOCH FROM NOW()), EXTRACT(EPOCH FROM NOW())) 
ON CONFLICT DO NOTHING
`

type AddRoleToUserParams struct {
	RoleID int64 `json:"role_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) AddRoleToUser(ctx context.Context, arg AddRoleToUserParams) error {
	_, err := q.db.Exec(ctx, addRoleToUser, arg.RoleID, arg.UserID)
	return err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO roles (name, description) 
VALUES ($1, $2) 
RETURNING id, name, description, created_at, updated_at
`

type CreatePermissionParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Role, error) {
	row := q.db.QueryRow(ctx, createPermission, arg.Name, arg.Description)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (name, description) 
VALUES ($1, $2) 
RETURNING id, name, description, created_at, updated_at
`

type CreateRoleParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, createRole, arg.Name, arg.Description)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions 
WHERE id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePermission, id)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles 
WHERE id = $1
`

func (q *Queries) DeleteRole(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRole, id)
	return err
}

const getPaginatedPermissionsByRoleID = `-- name: GetPaginatedPermissionsByRoleID :many
SELECT id, name, description, p.created_at, p.updated_at, role_id, permission_id, rp.created_at, rp.updated_at FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE 
    rp.role_id = $3  -- Filter by permission_id
    AND (coalesce($4, '') = '' OR p.name ILIKE '%' || $4 || '%')
    AND (coalesce($5, '') = '' OR p.description ILIKE '%' || $5 || '%')
ORDER BY 
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'ASC' THEN p.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'ASC' THEN p.description 
    END ASC,
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'DESC' THEN p.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'DESC' THEN p.description 
    END DESC
LIMIT $1
OFFSET $2
`

type GetPaginatedPermissionsByRoleIDParams struct {
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
	RoleID            pgtype.Int8 `json:"role_id"`
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
	SortField         interface{} `json:"sort_field"`
	SortOrder         interface{} `json:"sort_order"`
}

type GetPaginatedPermissionsByRoleIDRow struct {
	ID           int64  `json:"id"`
	Name         string `json:"name"`
	Description  string `json:"description"`
	CreatedAt    int64  `json:"created_at"`
	UpdatedAt    int64  `json:"updated_at"`
	RoleID       int64  `json:"role_id"`
	PermissionID int64  `json:"permission_id"`
	CreatedAt_2  int64  `json:"created_at_2"`
	UpdatedAt_2  int64  `json:"updated_at_2"`
}

func (q *Queries) GetPaginatedPermissionsByRoleID(ctx context.Context, arg GetPaginatedPermissionsByRoleIDParams) ([]GetPaginatedPermissionsByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedPermissionsByRoleID,
		arg.Limit,
		arg.Offset,
		arg.RoleID,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedPermissionsByRoleIDRow
	for rows.Next() {
		var i GetPaginatedPermissionsByRoleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedPermissionsByRoleIDCount = `-- name: GetPaginatedPermissionsByRoleIDCount :one
SELECT COUNT(*) FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE 
    rp.role_id = $1  -- Filter by permission_id
    AND (coalesce($2, '') = '' OR p.name ILIKE '%' || $2 || '%')
    AND (coalesce($3, '') = '' OR p.description ILIKE '%' || $3 || '%')
`

type GetPaginatedPermissionsByRoleIDCountParams struct {
	RoleID            pgtype.Int8 `json:"role_id"`
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
}

func (q *Queries) GetPaginatedPermissionsByRoleIDCount(ctx context.Context, arg GetPaginatedPermissionsByRoleIDCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPaginatedPermissionsByRoleIDCount, arg.RoleID, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPaginatedRolesByPermissionID = `-- name: GetPaginatedRolesByPermissionID :many
SELECT id, name, description, r.created_at, r.updated_at, role_id, permission_id, rp.created_at, rp.updated_at FROM roles r
JOIN role_permissions rp ON r.id = rp.role_id
WHERE 
    rp.permission_id = $3  -- Filter by permission_id
    AND (coalesce($4, '') = '' OR r.name ILIKE '%' || $4 || '%')
    AND (coalesce($5, '') = '' OR r.description ILIKE '%' || $5 || '%')
ORDER BY 
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'ASC' THEN r.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'ASC' THEN r.description 
    END ASC,
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'DESC' THEN r.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'DESC' THEN r.description 
    END DESC
LIMIT $1
OFFSET $2
`

type GetPaginatedRolesByPermissionIDParams struct {
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
	PermissionID      pgtype.Int8 `json:"permission_id"`
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
	SortField         interface{} `json:"sort_field"`
	SortOrder         interface{} `json:"sort_order"`
}

type GetPaginatedRolesByPermissionIDRow struct {
	ID           int64  `json:"id"`
	Name         string `json:"name"`
	Description  string `json:"description"`
	CreatedAt    int64  `json:"created_at"`
	UpdatedAt    int64  `json:"updated_at"`
	RoleID       int64  `json:"role_id"`
	PermissionID int64  `json:"permission_id"`
	CreatedAt_2  int64  `json:"created_at_2"`
	UpdatedAt_2  int64  `json:"updated_at_2"`
}

func (q *Queries) GetPaginatedRolesByPermissionID(ctx context.Context, arg GetPaginatedRolesByPermissionIDParams) ([]GetPaginatedRolesByPermissionIDRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedRolesByPermissionID,
		arg.Limit,
		arg.Offset,
		arg.PermissionID,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedRolesByPermissionIDRow
	for rows.Next() {
		var i GetPaginatedRolesByPermissionIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedRolesByPermissionIDCount = `-- name: GetPaginatedRolesByPermissionIDCount :one
SELECT COUNT(*) FROM roles r
JOIN role_permissions rp ON r.id = rp.role_id
WHERE 
    rp.permission_id = $1  -- Filter by permission_id
    AND (coalesce($2, '') = '' OR r.name ILIKE '%' || $2 || '%')
    AND (coalesce($3, '') = '' OR r.description ILIKE '%' || $3 || '%')
`

type GetPaginatedRolesByPermissionIDCountParams struct {
	PermissionID      pgtype.Int8 `json:"permission_id"`
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
}

func (q *Queries) GetPaginatedRolesByPermissionIDCount(ctx context.Context, arg GetPaginatedRolesByPermissionIDCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPaginatedRolesByPermissionIDCount, arg.PermissionID, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPaginatedRolesByUserID = `-- name: GetPaginatedRolesByUserID :many
SELECT id, name, description, r.created_at, r.updated_at, user_id, role_id, ur.created_at, ur.updated_at FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE 
    ur.user_id = $3  -- Filter by user_id
    AND (coalesce($4, '') = '' OR r.name ILIKE '%' || $4 || '%')
    AND (coalesce($5, '') = '' OR r.description ILIKE '%' || $5 || '%')
ORDER BY 
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'ASC' THEN r.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'ASC' THEN r.description 
    END ASC,
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'DESC' THEN r.name 
        WHEN $6 = 'DESCRIPTION' AND $7 = 'DESC' THEN r.description 
    END DESC
LIMIT $1
OFFSET $2
`

type GetPaginatedRolesByUserIDParams struct {
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
	UserID            pgtype.Int8 `json:"user_id"`
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
	SortField         interface{} `json:"sort_field"`
	SortOrder         interface{} `json:"sort_order"`
}

type GetPaginatedRolesByUserIDRow struct {
	ID          int64  `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	CreatedAt   int64  `json:"created_at"`
	UpdatedAt   int64  `json:"updated_at"`
	UserID      int64  `json:"user_id"`
	RoleID      int64  `json:"role_id"`
	CreatedAt_2 int64  `json:"created_at_2"`
	UpdatedAt_2 int64  `json:"updated_at_2"`
}

func (q *Queries) GetPaginatedRolesByUserID(ctx context.Context, arg GetPaginatedRolesByUserIDParams) ([]GetPaginatedRolesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedRolesByUserID,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedRolesByUserIDRow
	for rows.Next() {
		var i GetPaginatedRolesByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.RoleID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedRolesByUserIDCount = `-- name: GetPaginatedRolesByUserIDCount :one
SELECT COUNT(*) FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE 
    ur.user_id = $1  -- Filter by user_id
    AND (coalesce($2, '') = '' OR r.name ILIKE '%' || $2 || '%')
    AND (coalesce($3, '') = '' OR r.description ILIKE '%' || $3 || '%')
`

type GetPaginatedRolesByUserIDCountParams struct {
	UserID            pgtype.Int8 `json:"user_id"`
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
}

func (q *Queries) GetPaginatedRolesByUserIDCount(ctx context.Context, arg GetPaginatedRolesByUserIDCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPaginatedRolesByUserIDCount, arg.UserID, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPaginatedUsersByRoleID = `-- name: GetPaginatedUsersByRoleID :many
SELECT 
    u.id, 
    u.name, 
    u.email, 
    u.email_verified_at, 
    u.last_seen_at, 
    u.created_at, 
    u.updated_at, 
    u.deleted_at
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
WHERE 
    ur.role_id = $3  -- Filter by role_id
    AND (coalesce($4, '') = '' OR u.name ILIKE '%' || $4 || '%')
    AND (coalesce($5, '') = '' OR u.email ILIKE '%' || $5 || '%')
ORDER BY 
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'ASC' THEN u.name 
        WHEN $6 = 'EMAIL' AND $7 = 'ASC' THEN u.email 
    END ASC,
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'DESC' THEN u.name 
        WHEN $6 = 'EMAIL' AND $7 = 'DESC' THEN u.email 
    END DESC
LIMIT $1
OFFSET $2
`

type GetPaginatedUsersByRoleIDParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	RoleID      pgtype.Int8 `json:"role_id"`
	NameFilter  interface{} `json:"name_filter"`
	EmailFilter interface{} `json:"email_filter"`
	SortField   interface{} `json:"sort_field"`
	SortOrder   interface{} `json:"sort_order"`
}

type GetPaginatedUsersByRoleIDRow struct {
	ID              int64       `json:"id"`
	Name            string      `json:"name"`
	Email           string      `json:"email"`
	EmailVerifiedAt pgtype.Int8 `json:"email_verified_at"`
	LastSeenAt      int64       `json:"last_seen_at"`
	CreatedAt       int64       `json:"created_at"`
	UpdatedAt       int64       `json:"updated_at"`
	DeletedAt       pgtype.Int8 `json:"deleted_at"`
}

func (q *Queries) GetPaginatedUsersByRoleID(ctx context.Context, arg GetPaginatedUsersByRoleIDParams) ([]GetPaginatedUsersByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedUsersByRoleID,
		arg.Limit,
		arg.Offset,
		arg.RoleID,
		arg.NameFilter,
		arg.EmailFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedUsersByRoleIDRow
	for rows.Next() {
		var i GetPaginatedUsersByRoleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.EmailVerifiedAt,
			&i.LastSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedUsersByRoleIDCount = `-- name: GetPaginatedUsersByRoleIDCount :one
SELECT COUNT(*)
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
WHERE 
    ur.role_id = $1  -- Filter by role_id
    AND (coalesce($2, '') = '' OR u.name ILIKE '%' || $2 || '%')
    AND (coalesce($3, '') = '' OR u.email ILIKE '%' || $3 || '%')
`

type GetPaginatedUsersByRoleIDCountParams struct {
	RoleID      pgtype.Int8 `json:"role_id"`
	NameFilter  interface{} `json:"name_filter"`
	EmailFilter interface{} `json:"email_filter"`
}

func (q *Queries) GetPaginatedUsersByRoleIDCount(ctx context.Context, arg GetPaginatedUsersByRoleIDCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPaginatedUsersByRoleIDCount, arg.RoleID, arg.NameFilter, arg.EmailFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPermission = `-- name: GetPermission :one
SELECT id, name, description, created_at, updated_at 
FROM permissions 
WHERE id = $1
`

func (q *Queries) GetPermission(ctx context.Context, id int64) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermission, id)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPermissionsByRoleID = `-- name: GetPermissionsByRoleID :many
SELECT p.id, p.name, p.description, p.created_at, p.updated_at
FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE rp.role_id = $1
`

func (q *Queries) GetPermissionsByRoleID(ctx context.Context, roleID int64) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getPermissionsByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRole = `-- name: GetRole :one
SELECT id, name, description, created_at, updated_at 
FROM roles 
WHERE id = $1
`

func (q *Queries) GetRole(ctx context.Context, id int64) (Role, error) {
	row := q.db.QueryRow(ctx, getRole, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRolesByPermissionID = `-- name: GetRolesByPermissionID :many
SELECT r.id, r.name, r.description, r.created_at, r.updated_at
FROM roles r
JOIN role_permissions rp ON r.id = rp.role_id
WHERE rp.permission_id = $1
`

func (q *Queries) GetRolesByPermissionID(ctx context.Context, permissionID int64) ([]Role, error) {
	rows, err := q.db.Query(ctx, getRolesByPermissionID, permissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesByUserID = `-- name: GetRolesByUserID :many
SELECT r.id, r.name, r.description, r.created_at, r.updated_at
FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE ur.user_id = $1
`

func (q *Queries) GetRolesByUserID(ctx context.Context, userID int64) ([]Role, error) {
	rows, err := q.db.Query(ctx, getRolesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissions = `-- name: GetUserPermissions :many
SELECT p.name
        FROM permissions p
        JOIN role_permissions rp ON rp.permission_id = p.id
        JOIN user_roles ur ON ur.role_id = rp.role_id
        WHERE ur.user_id = $1
`

func (q *Queries) GetUserPermissions(ctx context.Context, userID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserPermissions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByRoleID = `-- name: GetUsersByRoleID :many
SELECT u.id, u.name, u.email, u.email_verified_at, u.last_seen_at, u.created_at, u.updated_at, u.deleted_at
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
WHERE ur.role_id = $1
`

type GetUsersByRoleIDRow struct {
	ID              int64       `json:"id"`
	Name            string      `json:"name"`
	Email           string      `json:"email"`
	EmailVerifiedAt pgtype.Int8 `json:"email_verified_at"`
	LastSeenAt      int64       `json:"last_seen_at"`
	CreatedAt       int64       `json:"created_at"`
	UpdatedAt       int64       `json:"updated_at"`
	DeletedAt       pgtype.Int8 `json:"deleted_at"`
}

func (q *Queries) GetUsersByRoleID(ctx context.Context, roleID int64) ([]GetUsersByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, getUsersByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByRoleIDRow
	for rows.Next() {
		var i GetUsersByRoleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.EmailVerifiedAt,
			&i.LastSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissions = `-- name: ListPermissions :many
SELECT id, name, description, created_at, updated_at FROM permissions
ORDER BY name
`

func (q *Queries) ListPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.Query(ctx, listPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, name, description, created_at, updated_at FROM roles
ORDER BY name
`

func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatedPermissions = `-- name: PaginatedPermissions :many
SELECT id, name, description, created_at, updated_at FROM permissions
WHERE 
    (coalesce($3, '') = '' OR name ILIKE '%' || $3 || '%')
    AND (coalesce($4, '') = '' OR description ILIKE '%' || $4 || '%')
ORDER BY 
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'ASC' THEN name 
        WHEN $5 = 'DESCRIPTION' AND $6 = 'ASC' THEN description 
    END ASC,
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'DESC' THEN name 
        WHEN $5 = 'DESCRIPTION' AND $6 = 'DESC' THEN description 
    END DESC
LIMIT $1
OFFSET $2
`

type PaginatedPermissionsParams struct {
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
	SortField         interface{} `json:"sort_field"`
	SortOrder         interface{} `json:"sort_order"`
}

func (q *Queries) PaginatedPermissions(ctx context.Context, arg PaginatedPermissionsParams) ([]Permission, error) {
	rows, err := q.db.Query(ctx, paginatedPermissions,
		arg.Limit,
		arg.Offset,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatedPermissionsCount = `-- name: PaginatedPermissionsCount :one
SELECT COUNT(*) FROM permissions
WHERE 
    (coalesce($1, '') = '' OR name ILIKE '%' || $1 || '%')
    AND (coalesce($2, '') = '' OR description ILIKE '%' || $2 || '%')
`

type PaginatedPermissionsCountParams struct {
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
}

func (q *Queries) PaginatedPermissionsCount(ctx context.Context, arg PaginatedPermissionsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, paginatedPermissionsCount, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const paginatedRoles = `-- name: PaginatedRoles :many
SELECT id, name, description, created_at, updated_at FROM roles
WHERE 
    (coalesce($3, '') = '' OR name ILIKE '%' || $3 || '%')
    AND (coalesce($4, '') = '' OR description ILIKE '%' || $4 || '%')
ORDER BY 
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'ASC' THEN name 
        WHEN $5 = 'DESCRIPTION' AND $6 = 'ASC' THEN description 
    END ASC,
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'DESC' THEN name 
        WHEN $5 = 'DESCRIPTION' AND $6 = 'DESC' THEN description 
    END DESC
LIMIT $1
OFFSET $2
`

type PaginatedRolesParams struct {
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
	SortField         interface{} `json:"sort_field"`
	SortOrder         interface{} `json:"sort_order"`
}

func (q *Queries) PaginatedRoles(ctx context.Context, arg PaginatedRolesParams) ([]Role, error) {
	rows, err := q.db.Query(ctx, paginatedRoles,
		arg.Limit,
		arg.Offset,
		arg.NameFilter,
		arg.DescriptionFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatedRolesCount = `-- name: PaginatedRolesCount :one
SELECT COUNT(*) FROM roles
WHERE 
    (coalesce($1, '') = '' OR name ILIKE '%' || $1 || '%')
    AND (coalesce($2, '') = '' OR description ILIKE '%' || $2 || '%')
`

type PaginatedRolesCountParams struct {
	NameFilter        interface{} `json:"name_filter"`
	DescriptionFilter interface{} `json:"description_filter"`
}

func (q *Queries) PaginatedRolesCount(ctx context.Context, arg PaginatedRolesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, paginatedRolesCount, arg.NameFilter, arg.DescriptionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const removePermissionFromRole = `-- name: RemovePermissionFromRole :exec
DELETE FROM role_permissions 
WHERE role_id = $1 AND permission_id = $2
`

type RemovePermissionFromRoleParams struct {
	RoleID       int64 `json:"role_id"`
	PermissionID int64 `json:"permission_id"`
}

func (q *Queries) RemovePermissionFromRole(ctx context.Context, arg RemovePermissionFromRoleParams) error {
	_, err := q.db.Exec(ctx, removePermissionFromRole, arg.RoleID, arg.PermissionID)
	return err
}

const removeRoleFromUser = `-- name: RemoveRoleFromUser :exec
DELETE FROM user_roles 
WHERE role_id = $1 AND user_id = $2
`

type RemoveRoleFromUserParams struct {
	RoleID int64 `json:"role_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) RemoveRoleFromUser(ctx context.Context, arg RemoveRoleFromUserParams) error {
	_, err := q.db.Exec(ctx, removeRoleFromUser, arg.RoleID, arg.UserID)
	return err
}

const updatePermission = `-- name: UpdatePermission :exec
UPDATE permissions 
SET name = $1, description = $2, updated_at = EXTRACT(EPOCH FROM NOW())
WHERE id = $3
`

type UpdatePermissionParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ID          int64  `json:"id"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) error {
	_, err := q.db.Exec(ctx, updatePermission, arg.Name, arg.Description, arg.ID)
	return err
}

const updateRole = `-- name: UpdateRole :exec
UPDATE roles 
SET name = $1, description = $2, updated_at = EXTRACT(EPOCH FROM NOW())
WHERE id = $3
`

type UpdateRoleParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ID          int64  `json:"id"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) error {
	_, err := q.db.Exec(ctx, updateRole, arg.Name, arg.Description, arg.ID)
	return err
}
