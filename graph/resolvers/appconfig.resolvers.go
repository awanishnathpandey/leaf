package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/awanishnathpandey/leaf/db/generated"
	"github.com/awanishnathpandey/leaf/graph"
	"github.com/awanishnathpandey/leaf/graph/model"
)

// UpdateAppConfig is the resolver for the updateAppConfig field.
func (r *mutationResolver) UpdateAppConfig(ctx context.Context, configKey string, configData map[string]interface{}) (*model.AppConfig, error) {
	// Convert the configData map into JSON
	configDataBytes, err := json.Marshal(configData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal configData: %w", err)
	}

	// Update the configuration in the database using sqlc
	// updatedConfig, err := r.DB.UpdateAppConfigByKey(ctx, generated.UpdateAppConfigByKeyParams{})(ctx, configKey, configDataBytes)
	// Call the sqlc generated query to update the folder in the database
	updatedConfig, err := r.DB.UpdateAppConfigByKey(ctx, generated.UpdateAppConfigByKeyParams{
		ConfigKey:  configKey,
		ConfigData: configDataBytes,
		UpdatedBy:  ctx.Value("userEmail").(string),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update configuration for key %s: %w", configKey, err)
	}

	// Dynamically unmarshal the updated configData to handle both map and array cases
	var configDataInterface interface{}
	if err := json.Unmarshal(updatedConfig.ConfigData, &configDataInterface); err != nil {
		return nil, fmt.Errorf("failed to unmarshal configData for key %s: %w", configKey, err)
	}

	// Check the dynamic type of configData
	switch v := configDataInterface.(type) {
	case map[string]interface{}:
		// If it's a map, use it directly
		return &model.AppConfig{
			ID:         updatedConfig.ID,
			ConfigKey:  updatedConfig.ConfigKey,
			ConfigData: v, // Directly assign map
			CreatedAt:  updatedConfig.CreatedAt,
			UpdatedAt:  updatedConfig.UpdatedAt,
			CreatedBy:  updatedConfig.CreatedBy,
			UpdatedBy:  updatedConfig.UpdatedBy,
		}, nil
	case []interface{}:
		// If it's an array, you can either leave it as-is or convert to a map as needed
		convertedMap := make(map[string]interface{})
		for i, item := range v {
			convertedMap[fmt.Sprintf("item_%d", i)] = item
		}
		return &model.AppConfig{
			ID:         updatedConfig.ID,
			ConfigKey:  updatedConfig.ConfigKey,
			ConfigData: convertedMap, // Convert array to map with item indices as keys
			CreatedAt:  updatedConfig.CreatedAt,
			UpdatedAt:  updatedConfig.UpdatedAt,
			CreatedBy:  updatedConfig.CreatedBy,
			UpdatedBy:  updatedConfig.UpdatedBy,
		}, nil
	default:
		return nil, fmt.Errorf("unsupported configData type for key %s: %T", configKey, configDataInterface)
	}
}

// GetAppConfig is the resolver for the getAppConfig field.
func (r *queryResolver) GetAppConfig(ctx context.Context, configKey string) (*model.AppConfig, error) {
	// Fetch configuration from the database using sqlc
	config, err := r.DB.GetAppConfigByKey(ctx, configKey)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch configuration for key %s: %w", configKey, err)
	}

	// Dynamically unmarshal the JSON to handle both map and array cases
	var configData interface{}
	if err := json.Unmarshal(config.ConfigData, &configData); err != nil {
		return nil, fmt.Errorf("failed to unmarshal configData: %w", err)
	}

	// Check the dynamic type of configData
	switch v := configData.(type) {
	case map[string]interface{}:
		// If it's a map, use it directly
		return &model.AppConfig{
			ID:         config.ID,
			ConfigKey:  config.ConfigKey,
			ConfigData: v, // Directly assign map
			CreatedAt:  config.CreatedAt,
			UpdatedAt:  config.UpdatedAt,
			CreatedBy:  config.CreatedBy,
			UpdatedBy:  config.UpdatedBy,
		}, nil
	case []interface{}:
		// If it's an array, you can either leave it as-is or convert to a map as needed
		// For example, we convert the array into a simple map with numeric keys
		convertedMap := make(map[string]interface{})
		for i, item := range v {
			convertedMap[fmt.Sprintf("item_%d", i)] = item
		}
		return &model.AppConfig{
			ID:         config.ID,
			ConfigKey:  config.ConfigKey,
			ConfigData: convertedMap, // Convert array to map with item indices as keys
			CreatedAt:  config.CreatedAt,
			UpdatedAt:  config.UpdatedAt,
			CreatedBy:  config.CreatedBy,
			UpdatedBy:  config.UpdatedBy,
		}, nil
	default:
		return nil, fmt.Errorf("unsupported configData type for key %s: %T", configKey, configData)
	}
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
