package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/awanishnathpandey/leaf/db/generated"
	"github.com/awanishnathpandey/leaf/graph/model"
	"github.com/awanishnathpandey/leaf/internal/middleware"
)

// CreateNotification is the resolver for the createNotification field.
func (r *mutationResolver) CreateNotification(ctx context.Context, input model.NotificationInput) (*model.Notification, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "create_notification"}

	// Check if the user has the required permissions
	if err := middleware.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}
	var payloadDataBytes []byte
	switch input.NotificationType {
	case "AppNotification":
		// Convert map[string]interface{} to JSON bytes
		var err error
		payloadDataBytes, err = json.Marshal(input.Payload)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal AppNotification payload: %w", err)
		}
		// Validate if it can unmarshal into AppNotificationPayload
		var tempPayload model.AppNotificationPayload
		if err := json.Unmarshal(payloadDataBytes, &tempPayload); err != nil {
			return nil, fmt.Errorf("invalid AppNotification payload: %w", err)
		}
	case "FileNotification":
		var err error
		payloadDataBytes, err = json.Marshal(input.Payload)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal FileNotification payload: %w", err)
		}
		// Validate if it can unmarshal into FileNotificationPayload
		var tempPayload model.FileNotificationPayload
		if err := json.Unmarshal(payloadDataBytes, &tempPayload); err != nil {
			return nil, fmt.Errorf("invalid FileNotification payload: %w", err)
		}
	default:
		return nil, fmt.Errorf("unknown notification type: %s", input.NotificationType)
	}

	// Call the generated function with the params
	notification, err := r.DB.CreateNotification(ctx, generated.CreateNotificationParams{
		NotificationType:   input.NotificationType,
		RecordKeyID:        input.RecordKeyID,
		Payload:            payloadDataBytes,
		StartTimeAt:        input.StartTimeAt,
		EndTimeAt:          input.EndTimeAt,
		IsPushNotification: input.IsPushNotification,
		Status:             input.Status,
		GroupIds:           input.GroupIds,
		UserIds:            input.UserIds,
		CreatedBy:          ctx.Value("userEmail").(string),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create notification: %w", err)
	}
	var notificationPayloadData map[string]interface{}
	// Unmarshal based on notification type
	switch notification.NotificationType {
	case "AppNotification":
		var an model.AppNotificationPayload
		if err := json.Unmarshal([]byte(notification.Payload), &an); err != nil {
			return nil, fmt.Errorf("failed to unmarshal AppNotification payload: %w", err)
		}
		// Convert struct to map
		data, err := json.Marshal(an)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal AppNotification payload to map: %w", err)
		}
		if err := json.Unmarshal(data, &notificationPayloadData); err != nil {
			return nil, fmt.Errorf("failed to unmarshal AppNotification payload to map: %w", err)
		}
	case "FileNotification":
		var fn model.FileNotificationPayload
		if err := json.Unmarshal([]byte(notification.Payload), &fn); err != nil {
			return nil, fmt.Errorf("failed to unmarshal FileNotification payload: %w", err)
		}
		// Convert struct to map
		data, err := json.Marshal(fn)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal FileNotification payload to map: %w", err)
		}
		if err := json.Unmarshal(data, &notificationPayloadData); err != nil {
			return nil, fmt.Errorf("failed to unmarshal FileNotification payload to map: %w", err)
		}
	default:
		return nil, fmt.Errorf("unknown notification type: %s", notification.NotificationType)
	}

	return &model.Notification{
		ID:                 notification.ID,
		NotificationType:   notification.NotificationType,
		RecordKeyID:        notification.RecordKeyID,
		Payload:            notificationPayloadData,
		StartTimeAt:        notification.StartTimeAt,
		EndTimeAt:          notification.EndTimeAt,
		IsPushNotification: notification.IsPushNotification,
		Status:             notification.Status,
		GroupIds:           notification.GroupIds,
		UserIds:            notification.UserIds,
		CreatedAt:          notification.CreatedAt,
		CreatedBy:          notification.CreatedBy,
	}, nil
}

// CreateNotificationTemplate is the resolver for the createNotificationTemplate field.
func (r *mutationResolver) CreateNotificationTemplate(ctx context.Context, input model.NotificationTemplateInput) (*model.NotificationTemplate, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "create_notification"}

	// Check if the user has the required permissions
	if err := middleware.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	responseOptions := make([]string, len(input.ResponseOptions))
	for i, option := range input.ResponseOptions {
		responseOptions[i] = *option
	}
	// Call the generated function with the params
	notificationTemplate, err := r.DB.CreateNotificationTemplate(ctx, generated.CreateNotificationTemplateParams{
		Title:           input.Title,
		Body:            input.Description,
		Description:     input.Description,
		ResponseOptions: responseOptions,
		CreatedBy:       ctx.Value("userEmail").(string),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create notification template: %w", err)
	}

	return &model.NotificationTemplate{
		ID:              notificationTemplate.ID,
		Title:           notificationTemplate.Title,
		Body:            notificationTemplate.Body,
		Description:     notificationTemplate.Description,
		ResponseOptions: notificationTemplate.ResponseOptions,
		CreatedBy:       notificationTemplate.CreatedBy,
		CreatedAt:       notificationTemplate.CreatedAt,
		UpdatedAt:       notificationTemplate.UpdatedAt,
		UpdatedBy:       notificationTemplate.UpdatedBy,
	}, nil
}

// RespondToNotification is the resolver for the respondToNotification field.
func (r *mutationResolver) RespondToNotification(ctx context.Context, input model.UserNotificationResponseInput) (*model.UserNotificationResponse, error) {
	panic(fmt.Errorf("not implemented: RespondToNotification - respondToNotification"))
}

// GetNotification is the resolver for the getNotification field.
func (r *queryResolver) GetNotification(ctx context.Context, id int64) (*model.Notification, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read", "create_notification"}

	// Check if the user has the required permissions
	if err := middleware.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	// Call the generated GetFolder query
	notification, err := r.DB.GetNotification(ctx, id) // assuming input.ID is of type string
	if err != nil {
		return nil, fmt.Errorf("failed to get notification: %w", err)
	}
	var notificationPayloadData map[string]interface{}
	// Unmarshal based on notification type
	switch notification.NotificationType {
	case "AppNotification":
		var an model.AppNotificationPayload
		if err := json.Unmarshal([]byte(notification.Payload), &an); err != nil {
			return nil, fmt.Errorf("failed to unmarshal AppNotification payload: %w", err)
		}
		// Convert struct to map
		data, err := json.Marshal(an)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal AppNotification payload to map: %w", err)
		}
		if err := json.Unmarshal(data, &notificationPayloadData); err != nil {
			return nil, fmt.Errorf("failed to unmarshal AppNotification payload to map: %w", err)
		}
	case "FileNotification":
		var fn model.FileNotificationPayload
		if err := json.Unmarshal([]byte(notification.Payload), &fn); err != nil {
			return nil, fmt.Errorf("failed to unmarshal FileNotification payload: %w", err)
		}
		// Convert struct to map
		data, err := json.Marshal(fn)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal FileNotification payload to map: %w", err)
		}
		if err := json.Unmarshal(data, &notificationPayloadData); err != nil {
			return nil, fmt.Errorf("failed to unmarshal FileNotification payload to map: %w", err)
		}
	default:
		return nil, fmt.Errorf("unknown notification type: %s", notification.NotificationType)
	}

	// Convert the SQL result to GraphQL model
	return &model.Notification{
		ID:                 notification.ID,
		NotificationType:   notification.NotificationType,
		RecordKeyID:        notification.RecordKeyID,
		Payload:            notificationPayloadData,
		StartTimeAt:        notification.StartTimeAt,
		EndTimeAt:          notification.EndTimeAt,
		IsPushNotification: notification.IsPushNotification,
		Status:             notification.Status,
		GroupIds:           notification.GroupIds,
		UserIds:            notification.UserIds,
		CreatedAt:          notification.CreatedAt,
		CreatedBy:          notification.CreatedBy,
	}, nil
}

// GetNotifications is the resolver for the getNotifications field.
func (r *queryResolver) GetNotifications(ctx context.Context) ([]*model.Notification, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read", "read_notification"}

	// Check if the user has the required permissions
	if err := middleware.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	notifications, err := r.DB.ListNotifications(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get notifications: %w", err)
	}

	// Convert the SQL result to GraphQL model
	var notificationModels []*model.Notification
	for _, notification := range notifications {
		var notificationPayloadData map[string]interface{}
		// Unmarshal based on notification type
		switch notification.NotificationType {
		case "AppNotification":
			var an model.AppNotificationPayload
			if err := json.Unmarshal([]byte(notification.Payload), &an); err != nil {
				return nil, fmt.Errorf("failed to unmarshal AppNotification payload: %w", err)
			}
			// Convert struct to map
			data, err := json.Marshal(an)
			if err != nil {
				return nil, fmt.Errorf("failed to marshal AppNotification payload to map: %w", err)
			}
			if err := json.Unmarshal(data, &notificationPayloadData); err != nil {
				return nil, fmt.Errorf("failed to unmarshal AppNotification payload to map: %w", err)
			}
		case "FileNotification":
			var fn model.FileNotificationPayload
			if err := json.Unmarshal([]byte(notification.Payload), &fn); err != nil {
				return nil, fmt.Errorf("failed to unmarshal FileNotification payload: %w", err)
			}
			// Convert struct to map
			data, err := json.Marshal(fn)
			if err != nil {
				return nil, fmt.Errorf("failed to marshal FileNotification payload to map: %w", err)
			}
			if err := json.Unmarshal(data, &notificationPayloadData); err != nil {
				return nil, fmt.Errorf("failed to unmarshal FileNotification payload to map: %w", err)
			}
		default:
			return nil, fmt.Errorf("unknown notification type: %s", notification.NotificationType)
		}
		notificationModels = append(notificationModels, &model.Notification{
			ID:                 notification.ID,
			NotificationType:   notification.NotificationType,
			RecordKeyID:        notification.RecordKeyID,
			Payload:            notificationPayloadData,
			StartTimeAt:        notification.StartTimeAt,
			EndTimeAt:          notification.EndTimeAt,
			IsPushNotification: notification.IsPushNotification,
			Status:             notification.Status,
			GroupIds:           notification.GroupIds,
			UserIds:            notification.UserIds,
			CreatedAt:          notification.CreatedAt,
			CreatedBy:          notification.CreatedBy,
		})
	}

	return notificationModels, nil
}

// GetNotificationTemplate is the resolver for the getNotificationTemplate field.
func (r *queryResolver) GetNotificationTemplate(ctx context.Context, id int64) (*model.NotificationTemplate, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read", "read_notification"}

	// Check if the user has the required permissions
	if err := middleware.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	// Call the generated GetFolder query
	notificationTemplate, err := r.DB.GetNotificationTemplate(ctx, id) // assuming input.ID is of type string
	if err != nil {
		return nil, fmt.Errorf("failed to get notification: %w", err)
	}

	// Convert the SQL result to GraphQL model
	return &model.NotificationTemplate{
		ID:              notificationTemplate.ID,
		Title:           notificationTemplate.Title,
		Body:            notificationTemplate.Body,
		Description:     notificationTemplate.Description,
		ResponseOptions: notificationTemplate.ResponseOptions,
		CreatedBy:       notificationTemplate.CreatedBy,
		CreatedAt:       notificationTemplate.CreatedAt,
		UpdatedAt:       notificationTemplate.UpdatedAt,
		UpdatedBy:       notificationTemplate.UpdatedBy,
	}, nil
}

// GetNotificationTemplates is the resolver for the getNotificationTemplates field.
func (r *queryResolver) GetNotificationTemplates(ctx context.Context) ([]*model.NotificationTemplate, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read", "read_notification"}

	// Check if the user has the required permissions
	if err := middleware.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	notificationTemplates, err := r.DB.ListNotificationTemplates(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get notification templates: %w", err)
	}

	// Convert the SQL result to GraphQL model
	var notificationTemplateModels []*model.NotificationTemplate
	for _, notificationTemplate := range notificationTemplates {
		notificationTemplateModels = append(notificationTemplateModels, &model.NotificationTemplate{
			ID:              notificationTemplate.ID,
			Title:           notificationTemplate.Title,
			Body:            notificationTemplate.Body,
			Description:     notificationTemplate.Description,
			ResponseOptions: notificationTemplate.ResponseOptions,
			CreatedBy:       notificationTemplate.CreatedBy,
			CreatedAt:       notificationTemplate.CreatedAt,
			UpdatedAt:       notificationTemplate.UpdatedAt,
			UpdatedBy:       notificationTemplate.UpdatedBy,
		})
	}

	return notificationTemplateModels, nil
}

// GetUserNotificationResponses is the resolver for the getUserNotificationResponses field.
func (r *queryResolver) GetUserNotificationResponses(ctx context.Context, userID int64) ([]*model.UserNotificationResponse, error) {
	panic(fmt.Errorf("not implemented: GetUserNotificationResponses - getUserNotificationResponses"))
}
