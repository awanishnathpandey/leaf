// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: file.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateFile = `-- name: CreateFile :one
INSERT INTO files (name, slug, file_path, file_type, file_bytes, file_content_type, auto_download, folder_id, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $9)
RETURNING id, name, slug, file_path, file_type, file_bytes, file_content_type, auto_download, folder_id, created_at, updated_at, created_by, updated_by
`

type CreateFileParams struct {
	Name            string `db:"name" json:"name"`
	Slug            string `db:"slug" json:"slug"`
	FilePath        string `db:"file_path" json:"file_path"`
	FileType        string `db:"file_type" json:"file_type"`
	FileBytes       int64  `db:"file_bytes" json:"file_bytes"`
	FileContentType string `db:"file_content_type" json:"file_content_type"`
	AutoDownload    bool   `db:"auto_download" json:"auto_download"`
	FolderID        int64  `db:"folder_id" json:"folder_id"`
	CreatedBy       string `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, CreateFile,
		arg.Name,
		arg.Slug,
		arg.FilePath,
		arg.FileType,
		arg.FileBytes,
		arg.FileContentType,
		arg.AutoDownload,
		arg.FolderID,
		arg.CreatedBy,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.FilePath,
		&i.FileType,
		&i.FileBytes,
		&i.FileContentType,
		&i.AutoDownload,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const DeleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, DeleteFile, id)
	return err
}

const DeleteFilesByIDs = `-- name: DeleteFilesByIDs :exec
DELETE FROM files
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteFilesByIDs(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, DeleteFilesByIDs, dollar_1)
	return err
}

const GetFile = `-- name: GetFile :one
SELECT id, name, slug, file_path, file_type, file_bytes, file_content_type, auto_download, folder_id, created_at, updated_at, created_by, updated_by FROM files
WHERE id = $1
`

func (q *Queries) GetFile(ctx context.Context, id int64) (File, error) {
	row := q.db.QueryRow(ctx, GetFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.FilePath,
		&i.FileType,
		&i.FileBytes,
		&i.FileContentType,
		&i.AutoDownload,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const GetFilesAndFoldersByUser = `-- name: GetFilesAndFoldersByUser :many
WITH epoch_7_days_ago AS (
    SELECT NOW() - INTERVAL '7 days' AS threshold
)
SELECT
    folder.id AS folder_id,
    folder.name AS folder_name,
    folder.slug AS folder_slug,
    folder.description AS folder_description,
    folder.created_at AS folder_created_at,
    folder.updated_at AS folder_updated_at,
    -- Adding "hasNewFile" based on files updated in the last 7 days
    CASE 
        WHEN EXISTS (
            SELECT 1
            FROM files f, epoch_7_days_ago e
            WHERE f.folder_id = folder.id
            AND f.file_type = $2  -- File type condition
            AND to_timestamp(f.updated_at) > e.threshold  -- Convert bigint to timestamp
        ) THEN true
        ELSE false
    END AS hasNewFile,
    f.id AS file_id,
    f.name AS file_name,
    f.slug AS file_slug,
    f.file_path AS file_path,
    f.file_type AS file_type,
    f.file_bytes AS file_bytes,
    f.file_content_type AS file_content_type,
    f.auto_download AS file_auto_download,
    f.folder_id AS file_folder_id,
    f.created_at AS file_created_at,
    f.updated_at AS file_updated_at,
    -- Adding "isNew" based on file update within the last 7 days
    CASE 
        WHEN to_timestamp(f.updated_at) > (SELECT threshold FROM epoch_7_days_ago) THEN true
        ELSE false
    END AS isNew
FROM files f
JOIN folders folder ON folder.id = f.folder_id
JOIN group_users gu ON gu.group_id IN (
    SELECT group_id FROM group_users WHERE group_users.user_id = $1
)
LEFT JOIN group_files gf ON gf.file_id = f.id
LEFT JOIN group_folders gfo ON gfo.folder_id = folder.id
WHERE gu.user_id = $1  -- The user ID is passed as the first parameter
AND f.file_type = $2  -- The file type (e.g., 'document') is passed as the second parameter
ORDER BY folder.name, f.name
`

type GetFilesAndFoldersByUserParams struct {
	UserID   int64  `db:"user_id" json:"user_id"`
	FileType string `db:"file_type" json:"file_type"`
}

type GetFilesAndFoldersByUserRow struct {
	FolderID          int64  `db:"folder_id" json:"folder_id"`
	FolderName        string `db:"folder_name" json:"folder_name"`
	FolderSlug        string `db:"folder_slug" json:"folder_slug"`
	FolderDescription string `db:"folder_description" json:"folder_description"`
	FolderCreatedAt   int64  `db:"folder_created_at" json:"folder_created_at"`
	FolderUpdatedAt   int64  `db:"folder_updated_at" json:"folder_updated_at"`
	Hasnewfile        bool   `db:"hasnewfile" json:"hasnewfile"`
	FileID            int64  `db:"file_id" json:"file_id"`
	FileName          string `db:"file_name" json:"file_name"`
	FileSlug          string `db:"file_slug" json:"file_slug"`
	FilePath          string `db:"file_path" json:"file_path"`
	FileType          string `db:"file_type" json:"file_type"`
	FileBytes         int64  `db:"file_bytes" json:"file_bytes"`
	FileContentType   string `db:"file_content_type" json:"file_content_type"`
	FileAutoDownload  bool   `db:"file_auto_download" json:"file_auto_download"`
	FileFolderID      int64  `db:"file_folder_id" json:"file_folder_id"`
	FileCreatedAt     int64  `db:"file_created_at" json:"file_created_at"`
	FileUpdatedAt     int64  `db:"file_updated_at" json:"file_updated_at"`
	Isnew             bool   `db:"isnew" json:"isnew"`
}

// Join the folders table to get folder details
// Join group_users to get the groups the user belongs to
// Join group_files to get the files directly associated with the user's groups
// Join group_folders to get the folders associated with the user's groups via the pivot table
func (q *Queries) GetFilesAndFoldersByUser(ctx context.Context, arg GetFilesAndFoldersByUserParams) ([]GetFilesAndFoldersByUserRow, error) {
	rows, err := q.db.Query(ctx, GetFilesAndFoldersByUser, arg.UserID, arg.FileType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesAndFoldersByUserRow{}
	for rows.Next() {
		var i GetFilesAndFoldersByUserRow
		if err := rows.Scan(
			&i.FolderID,
			&i.FolderName,
			&i.FolderSlug,
			&i.FolderDescription,
			&i.FolderCreatedAt,
			&i.FolderUpdatedAt,
			&i.Hasnewfile,
			&i.FileID,
			&i.FileName,
			&i.FileSlug,
			&i.FilePath,
			&i.FileType,
			&i.FileBytes,
			&i.FileContentType,
			&i.FileAutoDownload,
			&i.FileFolderID,
			&i.FileCreatedAt,
			&i.FileUpdatedAt,
			&i.Isnew,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetFilesAndFoldersByUserBB = `-- name: GetFilesAndFoldersByUserBB :many
SELECT
    folder.id AS folder_id,
    folder.name AS folder_name,
    folder.slug AS folder_slug,
    folder.description AS folder_description,
    folder.created_at AS folder_created_at,
    folder.updated_at AS folder_updated_at,
    f.id AS file_id,
    f.name AS file_name,
    f.slug AS file_slug,
    f.file_path AS file_path,
    f.file_type AS file_type,
    f.file_bytes AS file_bytes,
    f.file_content_type AS file_content_type,
    f.auto_download AS file_auto_download,
    f.folder_id AS file_folder_id,
    f.created_at AS file_created_at,
    f.updated_at AS file_updated_at
FROM files f
JOIN folders folder ON folder.id = f.folder_id
JOIN group_users gu ON gu.group_id IN (
    SELECT group_id FROM group_users WHERE group_users.user_id = $1
)
LEFT JOIN group_files gf ON gf.file_id = f.id
LEFT JOIN group_folders gfo ON gfo.folder_id = folder.id
WHERE gu.user_id = $1  -- The user ID is passed as the first parameter
AND f.file_type = $2  -- The file type (e.g., 'document') is passed as the second parameter
ORDER BY folder.name, f.name
`

type GetFilesAndFoldersByUserBBParams struct {
	UserID   int64  `db:"user_id" json:"user_id"`
	FileType string `db:"file_type" json:"file_type"`
}

type GetFilesAndFoldersByUserBBRow struct {
	FolderID          int64  `db:"folder_id" json:"folder_id"`
	FolderName        string `db:"folder_name" json:"folder_name"`
	FolderSlug        string `db:"folder_slug" json:"folder_slug"`
	FolderDescription string `db:"folder_description" json:"folder_description"`
	FolderCreatedAt   int64  `db:"folder_created_at" json:"folder_created_at"`
	FolderUpdatedAt   int64  `db:"folder_updated_at" json:"folder_updated_at"`
	FileID            int64  `db:"file_id" json:"file_id"`
	FileName          string `db:"file_name" json:"file_name"`
	FileSlug          string `db:"file_slug" json:"file_slug"`
	FilePath          string `db:"file_path" json:"file_path"`
	FileType          string `db:"file_type" json:"file_type"`
	FileBytes         int64  `db:"file_bytes" json:"file_bytes"`
	FileContentType   string `db:"file_content_type" json:"file_content_type"`
	FileAutoDownload  bool   `db:"file_auto_download" json:"file_auto_download"`
	FileFolderID      int64  `db:"file_folder_id" json:"file_folder_id"`
	FileCreatedAt     int64  `db:"file_created_at" json:"file_created_at"`
	FileUpdatedAt     int64  `db:"file_updated_at" json:"file_updated_at"`
}

// Join the folders table to get folder details
// Join group_users to get the groups the user belongs to
// Join group_files to get the files directly associated with the user's groups
// Join group_folders to get the folders associated with the user's groups via the pivot table
func (q *Queries) GetFilesAndFoldersByUserBB(ctx context.Context, arg GetFilesAndFoldersByUserBBParams) ([]GetFilesAndFoldersByUserBBRow, error) {
	rows, err := q.db.Query(ctx, GetFilesAndFoldersByUserBB, arg.UserID, arg.FileType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesAndFoldersByUserBBRow{}
	for rows.Next() {
		var i GetFilesAndFoldersByUserBBRow
		if err := rows.Scan(
			&i.FolderID,
			&i.FolderName,
			&i.FolderSlug,
			&i.FolderDescription,
			&i.FolderCreatedAt,
			&i.FolderUpdatedAt,
			&i.FileID,
			&i.FileName,
			&i.FileSlug,
			&i.FilePath,
			&i.FileType,
			&i.FileBytes,
			&i.FileContentType,
			&i.FileAutoDownload,
			&i.FileFolderID,
			&i.FileCreatedAt,
			&i.FileUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetFilesByFolder = `-- name: GetFilesByFolder :many
SELECT id, name, slug, file_path, file_type, file_bytes, file_content_type, auto_download, folder_id, created_at, updated_at, created_by, updated_by FROM files
WHERE folder_id = $1
`

func (q *Queries) GetFilesByFolder(ctx context.Context, folderID int64) ([]File, error) {
	rows, err := q.db.Query(ctx, GetFilesByFolder, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.FilePath,
			&i.FileType,
			&i.FileBytes,
			&i.FileContentType,
			&i.AutoDownload,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetFilesByFolderID = `-- name: GetFilesByFolderID :many
SELECT id, name, slug, file_path, file_type, file_bytes, file_content_type, auto_download, folder_id, created_at, updated_at, created_by, updated_by FROM files
WHERE folder_id = $1
`

func (q *Queries) GetFilesByFolderID(ctx context.Context, folderID int64) ([]File, error) {
	rows, err := q.db.Query(ctx, GetFilesByFolderID, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.FilePath,
			&i.FileType,
			&i.FileBytes,
			&i.FileContentType,
			&i.AutoDownload,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetFilesByIDs = `-- name: GetFilesByIDs :many
SELECT id FROM files
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetFilesByIDs(ctx context.Context, dollar_1 []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, GetFilesByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPaginatedFilesByFolderID = `-- name: GetPaginatedFilesByFolderID :many
SELECT id, name, slug, file_path, file_type, file_bytes, file_content_type, auto_download, folder_id, created_at, updated_at, created_by, updated_by FROM files WHERE 
    folder_id = $3  -- Filter by folder_id
    AND (coalesce($4, '') = '' OR name ILIKE '%' || $4 || '%')
    AND (coalesce($5, '') = '' OR slug ILIKE '%' || $5 || '%')
ORDER BY 
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'ASC' THEN name 
        WHEN $6 = 'SLUG' AND $7 = 'ASC' THEN slug 
    END ASC,
    CASE 
        WHEN $6 = 'NAME' AND $7 = 'DESC' THEN name 
        WHEN $6 = 'SLUG' AND $7 = 'DESC' THEN slug 
    END DESC
LIMIT $1
OFFSET $2
`

type GetPaginatedFilesByFolderIDParams struct {
	Limit      int32       `db:"limit" json:"limit"`
	Offset     int32       `db:"offset" json:"offset"`
	FolderID   pgtype.Int8 `db:"folder_id" json:"folder_id"`
	NameFilter interface{} `db:"name_filter" json:"name_filter"`
	SlugFilter interface{} `db:"slug_filter" json:"slug_filter"`
	SortField  interface{} `db:"sort_field" json:"sort_field"`
	SortOrder  interface{} `db:"sort_order" json:"sort_order"`
}

func (q *Queries) GetPaginatedFilesByFolderID(ctx context.Context, arg GetPaginatedFilesByFolderIDParams) ([]File, error) {
	rows, err := q.db.Query(ctx, GetPaginatedFilesByFolderID,
		arg.Limit,
		arg.Offset,
		arg.FolderID,
		arg.NameFilter,
		arg.SlugFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.FilePath,
			&i.FileType,
			&i.FileBytes,
			&i.FileContentType,
			&i.AutoDownload,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPaginatedFilesByFolderIDCount = `-- name: GetPaginatedFilesByFolderIDCount :one
SELECT COUNT(*) FROM files WHERE 
    folder_id = $1  -- Filter by folder_id
    AND (coalesce($2, '') = '' OR name ILIKE '%' || $2 || '%')
    AND (coalesce($3, '') = '' OR slug ILIKE '%' || $3 || '%')
`

type GetPaginatedFilesByFolderIDCountParams struct {
	FolderID   pgtype.Int8 `db:"folder_id" json:"folder_id"`
	NameFilter interface{} `db:"name_filter" json:"name_filter"`
	SlugFilter interface{} `db:"slug_filter" json:"slug_filter"`
}

func (q *Queries) GetPaginatedFilesByFolderIDCount(ctx context.Context, arg GetPaginatedFilesByFolderIDCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, GetPaginatedFilesByFolderIDCount, arg.FolderID, arg.NameFilter, arg.SlugFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const ListFiles = `-- name: ListFiles :many
SELECT id, name, slug, file_path, file_type, file_bytes, file_content_type, auto_download, folder_id, created_at, updated_at, created_by, updated_by FROM files
ORDER BY name
`

func (q *Queries) ListFiles(ctx context.Context) ([]File, error) {
	rows, err := q.db.Query(ctx, ListFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.FilePath,
			&i.FileType,
			&i.FileBytes,
			&i.FileContentType,
			&i.AutoDownload,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const PaginatedFiles = `-- name: PaginatedFiles :many
SELECT id, name, slug, file_path, file_type, file_bytes, file_content_type, auto_download, folder_id, created_at, updated_at, created_by, updated_by FROM files
WHERE 
    (coalesce($3, '') = '' OR name ILIKE '%' || $3 || '%')
    AND (coalesce($4, '') = '' OR slug ILIKE '%' || $4 || '%')
ORDER BY 
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'ASC' THEN name 
        WHEN $5 = 'SLUG' AND $6 = 'ASC' THEN slug 
    END ASC,
    CASE 
        WHEN $5 = 'NAME' AND $6 = 'DESC' THEN name 
        WHEN $5 = 'SLUG' AND $6 = 'DESC' THEN slug 
    END DESC
LIMIT $1
OFFSET $2
`

type PaginatedFilesParams struct {
	Limit      int32       `db:"limit" json:"limit"`
	Offset     int32       `db:"offset" json:"offset"`
	NameFilter interface{} `db:"name_filter" json:"name_filter"`
	SlugFilter interface{} `db:"slug_filter" json:"slug_filter"`
	SortField  interface{} `db:"sort_field" json:"sort_field"`
	SortOrder  interface{} `db:"sort_order" json:"sort_order"`
}

func (q *Queries) PaginatedFiles(ctx context.Context, arg PaginatedFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, PaginatedFiles,
		arg.Limit,
		arg.Offset,
		arg.NameFilter,
		arg.SlugFilter,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.FilePath,
			&i.FileType,
			&i.FileBytes,
			&i.FileContentType,
			&i.AutoDownload,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const PaginatedFilesCount = `-- name: PaginatedFilesCount :one
SELECT COUNT(*) FROM files
WHERE 
    (coalesce($1, '') = '' OR name ILIKE '%' || $1 || '%')
    AND (coalesce($2, '') = '' OR slug ILIKE '%' || $2 || '%')
`

type PaginatedFilesCountParams struct {
	NameFilter interface{} `db:"name_filter" json:"name_filter"`
	SlugFilter interface{} `db:"slug_filter" json:"slug_filter"`
}

func (q *Queries) PaginatedFilesCount(ctx context.Context, arg PaginatedFilesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, PaginatedFilesCount, arg.NameFilter, arg.SlugFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const UpdateFile = `-- name: UpdateFile :one
UPDATE files
SET name = $2, slug = $3, file_path = $4, file_bytes = $6, file_content_type = $7, auto_download = $8, updated_at = EXTRACT(EPOCH FROM NOW()), updated_by = $5
WHERE id = $1
RETURNING id, name, slug, file_path, file_type, file_bytes, file_content_type, auto_download, folder_id, created_at, updated_at, created_by, updated_by
`

type UpdateFileParams struct {
	ID              int64  `db:"id" json:"id"`
	Name            string `db:"name" json:"name"`
	Slug            string `db:"slug" json:"slug"`
	FilePath        string `db:"file_path" json:"file_path"`
	UpdatedBy       string `db:"updated_by" json:"updated_by"`
	FileBytes       int64  `db:"file_bytes" json:"file_bytes"`
	FileContentType string `db:"file_content_type" json:"file_content_type"`
	AutoDownload    bool   `db:"auto_download" json:"auto_download"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, UpdateFile,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.FilePath,
		arg.UpdatedBy,
		arg.FileBytes,
		arg.FileContentType,
		arg.AutoDownload,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.FilePath,
		&i.FileType,
		&i.FileBytes,
		&i.FileContentType,
		&i.AutoDownload,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}
