package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"

	"github.com/awanishnathpandey/leaf/db/generated"
	"github.com/awanishnathpandey/leaf/graph"
	"github.com/awanishnathpandey/leaf/graph/model"
	"github.com/awanishnathpandey/leaf/internal/utils"
	"github.com/jackc/pgx/v5/pgtype"
)

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, input model.CreateRole) (*model.Role, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "create_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}
	// Validate input
	if err := input.Validate(); err != nil {
		// Call the reusable validation error formatter
		return nil, utils.FormatValidationErrors(err)
	}

	// Call the generated CreateRole function with the params
	role, err := r.DB.CreateRole(ctx, generated.CreateRoleParams{
		Name:        input.Name,
		Description: input.Description,
		CreatedBy:   ctx.Value("userEmail").(string),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create role: %w", err)
	}

	// Return the newly created role
	return &model.Role{
		ID:          role.ID,
		Name:        role.Name,
		Description: role.Description,
		CreatedAt:   role.CreatedAt,
		UpdatedAt:   role.UpdatedAt,
		CreatedBy:   role.CreatedBy,
		UpdatedBy:   role.UpdatedBy,
	}, nil
}

// UpdateRole is the resolver for the updateRole field.
func (r *mutationResolver) UpdateRole(ctx context.Context, input model.UpdateRole) (*model.Role, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "update_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}
	// Check if the role exists
	_, err := r.DB.GetRole(ctx, input.ID)
	if err != nil {
		return nil, fmt.Errorf("role not found: %w", err)
	}

	// Call the sqlc generated query to update the role in the database
	role, err := r.DB.UpdateRole(ctx, generated.UpdateRoleParams{
		ID:          input.ID,
		Name:        input.Name,
		Description: input.Description,
		UpdatedBy:   ctx.Value("userEmail").(string),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update role: %w", err)
	}

	// Map the SQLC model to the GraphQL model
	return &model.Role{
		ID:          role.ID,
		Name:        role.Name,
		Description: role.Description,
		CreatedAt:   role.CreatedAt,
		UpdatedAt:   role.UpdatedAt,
	}, nil
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, id int64) (bool, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "delete_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return false, err
	}
	// Check if the role exists (optional)
	_, err := r.DB.GetRole(ctx, id)
	if err != nil {
		return false, fmt.Errorf("role not found: %w", err)
	}

	// Attempt to delete the role
	err = r.DB.DeleteRole(ctx, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete role: %w", err)
	}
	return true, nil
}

// DeleteRoles is the resolver for the deleteRoles field.
func (r *mutationResolver) DeleteRoles(ctx context.Context, ids []int64) (bool, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "delete_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return false, err
	}
	// Validate that all IDs exist
	existingFiles, err := r.DB.GetRolesByIDs(ctx, ids)
	if err != nil {
		return false, fmt.Errorf("failed to fetch roles: %w", err)
	}
	if len(existingFiles) != len(ids) {
		return false, fmt.Errorf("validation failed: some roles do not exist")
	}

	// Proceed to delete the files
	err = r.DB.DeleteRolesByIDs(ctx, ids)
	if err != nil {
		return false, fmt.Errorf("failed to delete roles: %w", err)
	}

	// All files successfully deleted
	return true, nil
}

// CreatePermission is the resolver for the createPermission field.
func (r *mutationResolver) CreatePermission(ctx context.Context, input model.CreatePermission) (*model.Permission, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "create_permission"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}
	// Validate input
	if err := input.Validate(); err != nil {
		// Call the reusable validation error formatter
		return nil, utils.FormatValidationErrors(err)
	}

	// Call the generated CreatePermission function with the params
	permission, err := r.DB.CreatePermission(ctx, generated.CreatePermissionParams{
		Name:        input.Name,
		Description: input.Description,
		CreatedBy:   ctx.Value("userEmail").(string),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create permission: %w", err)
	}

	// Return the newly created permission
	return &model.Permission{
		ID:          permission.ID,
		Name:        permission.Name,
		Description: permission.Description,
		CreatedAt:   permission.CreatedAt,
		UpdatedAt:   permission.UpdatedAt,
		CreatedBy:   permission.CreatedBy,
		UpdatedBy:   permission.UpdatedBy,
	}, nil
}

// UpdatePermission is the resolver for the updatePermission field.
func (r *mutationResolver) UpdatePermission(ctx context.Context, input model.UpdatePermission) (*model.Permission, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "update_permission"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}
	// Check if the permission exists
	_, err := r.DB.GetPermission(ctx, input.ID)
	if err != nil {
		return nil, fmt.Errorf("permission not found: %w", err)
	}

	// Call the sqlc generated query to update the permission in the database
	permission, err := r.DB.UpdatePermission(ctx, generated.UpdatePermissionParams{
		ID:          input.ID,
		Name:        input.Name,
		Description: input.Description,
		UpdatedBy:   ctx.Value("userEmail").(string),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update permission: %w", err)
	}

	// Map the SQLC model to the GraphQL model
	return &model.Permission{
		ID:          permission.ID,
		Name:        permission.Name,
		Description: permission.Description,
		CreatedAt:   permission.CreatedAt,
		UpdatedAt:   permission.UpdatedAt,
		CreatedBy:   permission.CreatedBy,
		UpdatedBy:   permission.UpdatedBy,
	}, nil
}

// DeletePermission is the resolver for the deletePermission field.
func (r *mutationResolver) DeletePermission(ctx context.Context, id int64) (bool, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "delete_permission"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return false, err
	}
	// Check if the permission exists (optional)
	_, err := r.DB.GetPermission(ctx, id)
	if err != nil {
		return false, fmt.Errorf("permission not found: %w", err)
	}

	// Attempt to delete the permission
	err = r.DB.DeletePermission(ctx, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete permission: %w", err)
	}
	return true, nil
}

// DeletePermissions is the resolver for the deletePermissions field.
func (r *mutationResolver) DeletePermissions(ctx context.Context, ids []int64) (bool, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "delete_permission"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return false, err
	}
	// Validate that all IDs exist
	existingFiles, err := r.DB.GetPermissionsByIDs(ctx, ids)
	if err != nil {
		return false, fmt.Errorf("failed to fetch permissions: %w", err)
	}
	if len(existingFiles) != len(ids) {
		return false, fmt.Errorf("validation failed: some permissions do not exist")
	}

	// Proceed to delete the files
	err = r.DB.DeletePermissionsByIDs(ctx, ids)
	if err != nil {
		return false, fmt.Errorf("failed to delete permissions: %w", err)
	}

	// All files successfully deleted
	return true, nil
}

// AddRoleToUser is the resolver for the addRoleToUser field.
func (r *mutationResolver) AddRoleToUser(ctx context.Context, roleID int64, userID int64) (bool, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "update_user"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return false, err
	}
	// Check if the role exists
	_, roleErr := r.DB.GetRole(ctx, roleID)
	if roleErr != nil {
		return false, fmt.Errorf("role not found: %w", roleErr)
	}

	// Check if the user exists
	_, err := r.DB.GetUser(ctx, userID)
	if err != nil {
		return false, fmt.Errorf("user not found: %w", err)
	}

	err = r.DB.AddRoleToUser(ctx, generated.AddRoleToUserParams{
		RoleID: roleID,
		UserID: userID,
	})
	if err != nil {
		return false, fmt.Errorf("failed to add role to user: %w", err)
	}
	return true, nil
}

// RemoveRoleFromUser is the resolver for the removeRoleFromUser field.
func (r *mutationResolver) RemoveRoleFromUser(ctx context.Context, roleID int64, userID int64) (bool, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "update_user"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return false, err
	}
	// Check if the role exists
	_, roleErr := r.DB.GetRole(ctx, roleID)
	if roleErr != nil {
		return false, fmt.Errorf("role not found: %w", roleErr)
	}

	// Check if the user exists
	_, err := r.DB.GetUser(ctx, userID)
	if err != nil {
		return false, fmt.Errorf("user not found: %w", err)
	}

	err = r.DB.RemoveRoleFromUser(ctx, generated.RemoveRoleFromUserParams{
		RoleID: roleID,
		UserID: userID,
	})
	if err != nil {
		return false, fmt.Errorf("failed to remove role from user: %w", err)
	}
	return true, nil
}

// AddPermissionToRole is the resolver for the addPermissionToRole field.
func (r *mutationResolver) AddPermissionToRole(ctx context.Context, roleID int64, permissionID int64) (bool, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "update_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return false, err
	}
	// Check if the role exists
	_, roleErr := r.DB.GetRole(ctx, roleID)
	if roleErr != nil {
		return false, fmt.Errorf("role not found: %w", roleErr)
	}

	// Check if the permission exists
	_, err := r.DB.GetPermission(ctx, permissionID)
	if err != nil {
		return false, fmt.Errorf("permission not found: %w", err)
	}

	err = r.DB.AddPermissionToRole(ctx, generated.AddPermissionToRoleParams{
		RoleID:       roleID,
		PermissionID: permissionID,
	})
	if err != nil {
		return false, fmt.Errorf("failed to add permission to role: %w", err)
	}
	return true, nil
}

// RemovePermissionFromRole is the resolver for the removePermissionFromRole field.
func (r *mutationResolver) RemovePermissionFromRole(ctx context.Context, roleID int64, permissionID int64) (bool, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "update_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return false, err
	}
	// Check if the role exists
	_, roleErr := r.DB.GetRole(ctx, roleID)
	if roleErr != nil {
		return false, fmt.Errorf("role not found: %w", roleErr)
	}

	// Check if the permission exists
	_, err := r.DB.GetPermission(ctx, permissionID)
	if err != nil {
		return false, fmt.Errorf("permission not found: %w", err)
	}

	err = r.DB.RemovePermissionFromRole(ctx, generated.RemovePermissionFromRoleParams{
		RoleID:       roleID,
		PermissionID: permissionID,
	})
	if err != nil {
		return false, fmt.Errorf("failed to remove permission from role: %w", err)
	}
	return true, nil
}

// Roles is the resolver for the roles field.
func (r *permissionResolver) Roles(ctx context.Context, obj *model.Permission, first int64, after *int64, filter *model.RoleFilter, sort *model.RoleSort) (*model.RoleConnection, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read_role", "read_permission"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	// Prepare sorting
	sortField := "NAME" // Default sort field
	sortOrder := "ASC"  // Default sort order
	if sort != nil {
		// Prepare sorting using the utility
		sortField, sortOrder = utils.PrepareSorting("NAME", "ASC", string(sort.Field), string(sort.Order))
	}

	// Calculate pagination and sorting
	offset, first := utils.PreparePaginationParams(after, first)

	// Prepare filter values
	var nameFilter, descriptionFilter *string
	if filter != nil {
		nameFilter = filter.Name
		descriptionFilter = filter.Description
	}

	// Fetch roles using the SQL query method for permission ID
	roles, err := r.DB.GetPaginatedRolesByPermissionID(ctx, generated.GetPaginatedRolesByPermissionIDParams{
		PermissionID:      pgtype.Int8{Int64: obj.ID, Valid: true}, // Group ID from the Group object
		Limit:             int32(first),                            // Limit based on 'first' argument
		Offset:            int32(offset),                           // Offset based on 'after' cursor
		NameFilter:        nameFilter,                              // Name filter (optional)
		DescriptionFilter: descriptionFilter,                       // Email filter (optional)
		SortField:         sortField,                               // Sorting field
		SortOrder:         sortOrder,                               // Sorting order
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch roles for permission %d: %v", obj.ID, err)
	}

	// Fetch filtered count using sqlc
	totalCount, err := r.DB.GetPaginatedRolesByPermissionIDCount(ctx, generated.GetPaginatedRolesByPermissionIDCountParams{
		PermissionID:      pgtype.Int8{Int64: obj.ID, Valid: true},
		NameFilter:        nameFilter,
		DescriptionFilter: descriptionFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query roles count for permission %d: %v", obj.ID, err)
	}

	// Prepare edges and PageInfo for the connection
	edges := make([]*model.RoleEdge, len(roles))
	for i, role := range roles {
		edges[i] = &model.RoleEdge{
			Cursor: utils.GenerateCursor(offset, int64(i)), // Create cursor from index
			Node: &model.Role{
				ID:          role.ID,
				Name:        role.Name,
				Description: role.Description,
				CreatedAt:   role.CreatedAt,
				UpdatedAt:   role.UpdatedAt,
				CreatedBy:   role.CreatedBy,
				UpdatedBy:   role.UpdatedBy,
			},
		}
	}

	// Calculate hasNextPage
	hasNextPage := utils.CalculateHasNextPage(offset, int64(len(roles)), totalCount)

	return &model.RoleConnection{
		TotalCount: totalCount,
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
		},
	}, nil
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context, first int64, after *int64, filter *model.RoleFilter, sort *model.RoleSort) (*model.RoleConnection, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	// Prepare sorting
	sortField := "NAME" // Default sort field
	sortOrder := "ASC"  // Default sort order
	if sort != nil {
		// Prepare sorting using the utility
		sortField, sortOrder = utils.PrepareSorting("NAME", "ASC", string(sort.Field), string(sort.Order))
	}

	// Calculate pagination and sorting
	offset, first := utils.PreparePaginationParams(after, first)

	// Prepare filter values
	var nameFilter, descriptionFilter *string
	if filter != nil {
		nameFilter = filter.Name
		descriptionFilter = filter.Description
	}
	// Fetch roles using sqlc
	roles, err := r.DB.PaginatedRoles(ctx, generated.PaginatedRolesParams{
		Limit:             int32(first),
		Offset:            int32(offset),
		NameFilter:        nameFilter,
		DescriptionFilter: descriptionFilter,
		SortField:         sortField,
		SortOrder:         sortOrder,
	}) // Assuming ListRoles is the sqlc query method
	if err != nil {
		return nil, fmt.Errorf("failed to query roles: %v", err)
	}

	// Fetch filtered count using sqlc
	totalCount, err := r.DB.PaginatedRolesCount(ctx, generated.PaginatedRolesCountParams{
		NameFilter:        nameFilter,
		DescriptionFilter: descriptionFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query roles count: %v", err)
	}

	// Prepare edges and PageInfo
	edges := make([]*model.RoleEdge, len(roles))
	for i, role := range roles {
		edges[i] = &model.RoleEdge{
			Cursor: utils.GenerateCursor(offset, int64(i)), // Create cursor from index
			Node: &model.Role{
				ID:          role.ID,
				Name:        role.Name,
				Description: role.Description,
				CreatedAt:   role.CreatedAt,
				UpdatedAt:   role.UpdatedAt,
				CreatedBy:   role.CreatedBy,
				UpdatedBy:   role.UpdatedBy,
			},
		}
	}

	// Calculate hasNextPage
	hasNextPage := utils.CalculateHasNextPage(offset, int64(len(roles)), totalCount)

	return &model.RoleConnection{
		TotalCount: totalCount,
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
		},
	}, nil
}

// Permissions is the resolver for the permissions field.
func (r *queryResolver) Permissions(ctx context.Context, first int64, after *int64, filter *model.PermissionFilter, sort *model.PermissionSort) (*model.PermissionConnection, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read_permission"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	// Prepare sorting
	sortField := "NAME" // Default sort field
	sortOrder := "ASC"  // Default sort order
	if sort != nil {
		// Prepare sorting using the utility
		sortField, sortOrder = utils.PrepareSorting("NAME", "ASC", string(sort.Field), string(sort.Order))
	}

	// Calculate pagination and sorting
	offset, first := utils.PreparePaginationParams(after, first)

	// Prepare filter values
	var nameFilter, descriptionFilter *string
	if filter != nil {
		nameFilter = filter.Name
		descriptionFilter = filter.Description
	}
	// Fetch permissions using sqlc
	permissions, err := r.DB.PaginatedPermissions(ctx, generated.PaginatedPermissionsParams{
		Limit:             int32(first),
		Offset:            int32(offset),
		NameFilter:        nameFilter,
		DescriptionFilter: descriptionFilter,
		SortField:         sortField,
		SortOrder:         sortOrder,
	}) // Assuming ListGroups is the sqlc query method
	if err != nil {
		return nil, fmt.Errorf("failed to query permissions: %v", err)
	}

	// Fetch filtered count using sqlc
	totalCount, err := r.DB.PaginatedPermissionsCount(ctx, generated.PaginatedPermissionsCountParams{
		NameFilter:        nameFilter,
		DescriptionFilter: descriptionFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query permissions count: %v", err)
	}

	// Prepare edges and PageInfo
	edges := make([]*model.PermissionEdge, len(permissions))
	for i, permission := range permissions {
		edges[i] = &model.PermissionEdge{
			Cursor: utils.GenerateCursor(offset, int64(i)), // Create cursor from index
			Node: &model.Permission{
				ID:          permission.ID,
				Name:        permission.Name,
				Description: permission.Description,
				CreatedAt:   permission.CreatedAt,
				UpdatedAt:   permission.UpdatedAt,
				CreatedBy:   permission.CreatedBy,
				UpdatedBy:   permission.UpdatedBy,
			},
		}
	}

	// Calculate hasNextPage
	hasNextPage := utils.CalculateHasNextPage(offset, int64(len(permissions)), totalCount)

	return &model.PermissionConnection{
		TotalCount: totalCount,
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
		},
	}, nil
}

// GetRole is the resolver for the getRole field.
func (r *queryResolver) GetRole(ctx context.Context, id int64) (*model.Role, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}
	// Call the generated GetRole query
	role, err := r.DB.GetRole(ctx, id) // assuming input.ID is of type string
	if err != nil {
		return nil, fmt.Errorf("failed to get role: %w", err)
	}

	// Convert the SQL result to GraphQL model
	return &model.Role{
		ID:          role.ID,
		Name:        role.Name,
		Description: role.Description,
		CreatedAt:   role.CreatedAt, // assuming you're using timestamptz
		UpdatedAt:   role.UpdatedAt, // assuming you're using timestamptz
	}, nil
}

// GetPermission is the resolver for the getPermission field.
func (r *queryResolver) GetPermission(ctx context.Context, id int64) (*model.Permission, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read_permission"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}
	// Call the generated GetPermission query
	permission, err := r.DB.GetPermission(ctx, id) // assuming input.ID is of type string
	if err != nil {
		return nil, fmt.Errorf("failed to get permission: %w", err)
	}

	// Convert the SQL result to GraphQL model
	return &model.Permission{
		ID:          permission.ID,
		Name:        permission.Name,
		Description: permission.Description,
		CreatedAt:   permission.CreatedAt, // assuming you're using timestamptz
		UpdatedAt:   permission.UpdatedAt, // assuming you're using timestamptz
	}, nil
}

// Permissions is the resolver for the permissions field.
func (r *roleResolver) Permissions(ctx context.Context, obj *model.Role, first int64, after *int64, filter *model.PermissionFilter, sort *model.PermissionSort) (*model.PermissionConnection, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read_permission", "read_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	// Prepare sorting
	sortField := "NAME" // Default sort field
	sortOrder := "ASC"  // Default sort order
	if sort != nil {
		// Prepare sorting using the utility
		sortField, sortOrder = utils.PrepareSorting("NAME", "ASC", string(sort.Field), string(sort.Order))
	}

	// Calculate pagination and sorting
	offset, first := utils.PreparePaginationParams(after, first)

	// Prepare filter values
	var nameFilter, descriptionFilter *string
	if filter != nil {
		nameFilter = filter.Name
		descriptionFilter = filter.Description
	}

	// Fetch permissions using the SQL query method for permission ID
	permissions, err := r.DB.GetPaginatedPermissionsByRoleID(ctx, generated.GetPaginatedPermissionsByRoleIDParams{
		RoleID:            pgtype.Int8{Int64: obj.ID, Valid: true}, // Role ID from the Group object
		Limit:             int32(first),                            // Limit based on 'first' argument
		Offset:            int32(offset),                           // Offset based on 'after' cursor
		NameFilter:        nameFilter,                              // Name filter (optional)
		DescriptionFilter: descriptionFilter,                       // Email filter (optional)
		SortField:         sortField,                               // Sorting field
		SortOrder:         sortOrder,                               // Sorting order
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch permissions for role %d: %v", obj.ID, err)
	}

	// Fetch filtered count using sqlc
	totalCount, err := r.DB.GetPaginatedPermissionsByRoleIDCount(ctx, generated.GetPaginatedPermissionsByRoleIDCountParams{
		RoleID:            pgtype.Int8{Int64: obj.ID, Valid: true},
		NameFilter:        nameFilter,
		DescriptionFilter: descriptionFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query permissions count for role %d: %v", obj.ID, err)
	}

	// Prepare edges and PageInfo for the connection
	edges := make([]*model.PermissionEdge, len(permissions))
	for i, permission := range permissions {
		edges[i] = &model.PermissionEdge{
			Cursor: utils.GenerateCursor(offset, int64(i)), // Create cursor from index
			Node: &model.Permission{
				ID:          permission.ID,
				Name:        permission.Name,
				Description: permission.Description,
				CreatedAt:   permission.CreatedAt,
				UpdatedAt:   permission.UpdatedAt,
				CreatedBy:   permission.CreatedBy,
				UpdatedBy:   permission.UpdatedBy,
			},
		}
	}

	// Calculate hasNextPage
	hasNextPage := utils.CalculateHasNextPage(offset, int64(len(permissions)), totalCount)

	return &model.PermissionConnection{
		TotalCount: totalCount,
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
		},
	}, nil
}

// Users is the resolver for the users field.
func (r *roleResolver) Users(ctx context.Context, obj *model.Role, first int64, after *int64, filter *model.UserFilter, sort *model.UserSort) (*model.UserConnection, error) {
	// Define the required permissions for this action
	requiredPermissions := []string{"all", "read_user", "read_role"}

	// Check if the user has the required permissions
	if err := utils.CheckUserPermissions(ctx, requiredPermissions, r.DB); err != nil {
		return nil, err
	}

	// Prepare sorting
	sortField := "NAME" // Default sort field
	sortOrder := "ASC"  // Default sort order
	if sort != nil {
		// Prepare sorting using the utility
		sortField, sortOrder = utils.PrepareSorting("NAME", "ASC", string(sort.Field), string(sort.Order))
	}

	// Calculate pagination and sorting
	offset, first := utils.PreparePaginationParams(after, first)

	// Prepare filter values
	var nameFilter, emailFilter *string
	if filter != nil {
		nameFilter = filter.Name
		emailFilter = filter.Email
	}

	// Fetch users using the SQL query method for role ID
	users, err := r.DB.GetPaginatedUsersByRoleID(ctx, generated.GetPaginatedUsersByRoleIDParams{
		RoleID:      pgtype.Int8{Int64: obj.ID, Valid: true}, // Group ID from the Group object
		Limit:       int32(first),                            // Limit based on 'first' argument
		Offset:      int32(offset),                           // Offset based on 'after' cursor
		NameFilter:  nameFilter,                              // Name filter (optional)
		EmailFilter: emailFilter,                             // Email filter (optional)
		SortField:   sortField,                               // Sorting field
		SortOrder:   sortOrder,                               // Sorting order
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch users for role %d: %v", obj.ID, err)
	}

	// Fetch filtered count using sqlc
	totalCount, err := r.DB.GetPaginatedUsersByRoleIDCount(ctx, generated.GetPaginatedUsersByRoleIDCountParams{
		RoleID:      pgtype.Int8{Int64: obj.ID, Valid: true},
		NameFilter:  nameFilter,
		EmailFilter: emailFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query users count for role %d: %v", obj.ID, err)
	}

	// Prepare edges and PageInfo for the connection
	edges := make([]*model.UserEdge, len(users))
	for i, user := range users {
		edges[i] = &model.UserEdge{
			Cursor: utils.GenerateCursor(offset, int64(i)), // Create cursor from index
			Node: &model.User{
				ID:              user.ID,
				FirstName:       user.FirstName,
				LastName:        user.LastName,
				Email:           user.Email,
				JobTitle:        &user.JobTitle.String,
				LineOfBusiness:  &user.LineOfBusiness.String,
				LineManager:     &user.LineManager.String,
				EmailVerifiedAt: (*int64)(&user.EmailVerifiedAt.Int64),
				LastSeenAt:      user.LastSeenAt,
				CreatedAt:       user.CreatedAt,
				UpdatedAt:       user.UpdatedAt,
				DeletedAt:       (*int64)(&user.DeletedAt.Int64),
				CreatedBy:       user.CreatedBy,
				UpdatedBy:       user.UpdatedBy,
			},
		}
	}

	// Calculate hasNextPage
	hasNextPage := utils.CalculateHasNextPage(offset, int64(len(users)), totalCount)

	return &model.UserConnection{
		TotalCount: totalCount,
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
		},
	}, nil
}

// Permission returns graph.PermissionResolver implementation.
func (r *Resolver) Permission() graph.PermissionResolver { return &permissionResolver{r} }

// Role returns graph.RoleResolver implementation.
func (r *Resolver) Role() graph.RoleResolver { return &roleResolver{r} }

type permissionResolver struct{ *Resolver }
type roleResolver struct{ *Resolver }
